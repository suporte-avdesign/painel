/**
 *     ___ _    __   ____            _
 *    /   | |  / /  / __ \___  _____(_)____ ____ 
 *   / /| | | / /  / / / / _ \/ ___/ / __ `/ __ \
 *  / ___ | |/ /  / /_/ /  __(__  ) / /_/ / / / /
 * /_/  |_|___/  /_____/\___/____/_/\__, /_/ /_/ 
 *                                 /____/        
 * ------------ By Anselmo Velame --------------- 
 *
 * Global template functions
 *
 * Content:
 * 1. Variables declaration
 * 2. Template interface
 * 3. Features detection
 * 4. Touch optimization
 * 5. Position: fixed polyfill
 * 6. Generic functions
 * 7. Custom events
 * 8. DOM watching functions
 * 9. Template setup functions
 * 10. Template setup
 * 11. Viewport resizing handling
 * 12. Template init
 * 13. Event delegation for template elements
 * 14. Tracked elements
 * 15. Custom animations
 * 16. Mobile browser chrome hidding
 * 17. Dependencies
 *
 * Structural good practices from the article from Addy Osmani 'Essential jQuery plugin patterns'
 * @url http://coding.smashingmagazine.com/2011/10/11/essential-jquery-plugin-patterns/
 */

/*
 * The semi-colon before the function invocation is a safety
 * net against concatenated scripts and/or other plugins
 * that are not closed properly.
 */
;(function($, window, document, undefined)
{
	/*
	 * undefined is used here as the undefined global variable in ECMAScript 3 is mutable (i.e. it can
	 * be changed by someone else). undefined isn't really being passed in so we can ensure that its value is
	 * truly undefined. In ES5, undefined can no longer be modified.
	 */

	/*
	 * window and document are passed through as local variables rather than as globals, because this (slightly)
	 * quickens the resolution process and can be more efficiently minified.
	 */

	/********************************************************/
	/*               1. Variables declaration               */
	/********************************************************/

		// Objects cache
	var win = $(window),
		doc = $(document),
		bod = $(document.body),

		// Whether auto-watching DOM changes or not
		autoWatch = true,

		// Recursion prevention in setup/clear watcher functions (prevent unnecessary processing)
		watching = true,

		// List of setup functions
		setupFunctions = [],

		// List of clear functions
		clearFunctions = [],

		// Store the timeout id for window.resize
		resizeInt = false,

		// List of media queries sizes with corresponding width of the test element
		mediaQueries = [
			[10, 'mobile-portrait'],
			[20, 'mobile-landscape'],
			[30, 'tablet-portrait'],
			[40, 'tablet-landscape'],
			[50, 'desktop']
		],

		// Height of the test element if a high-res screen is on
		hiresTestHeight = 20,

		// Position:fixed support
		fixedTest, supportFixed = true, fixed = $(),

		// Touchend instead of click support
		touchMoved = false, touchId = 0,

		// Template has been inited
		init = false;

	/********************************************************/
	/*                2. Template interface                 */
	/********************************************************/

	// Public template methods and vars will be created in here
	$.template = {

		/*
		 * Key map for easier code reading
		 */
		keys: {
			tab   : 9,
			enter : 13,
			space : 32,
			left  : 37,
			up    : 38,
			right : 39,
			down  : 40
		},

		/**
		 * Path to the respond.js folder: use either a relative path, an absolute path, or dynamic path detection
		 * @var string
		 */
		//respondPath: 'js/libs/',														/* Relative path  */
		//respondPath: '/myApp/js/libs/',												/* Absolute path  */
		respondPath: $('script').last().attr('src').replace(/[^\/]+$/, '')+'libs/',		/* Path detection */

		/*
		 * Here are stored various informations about the current media queries according to screen size
		 */
		mediaQuery: {

			/**
			 * Current largest media query name (one of 'mobile-portrait', 'mobile-landscape', 'tablet-portrait', 'tablet-landscape', 'desktop')
			 * @var string
			 */
			name: 'mobile-portrait',

			/**
			 * List of all media query active
			 * @var array
			 */
			on: ['mobile-portrait'],

			/**
			 * True if a hi-res screen (i.e. iPhone's Retina screen) is on
			 * @var boolean
			 */
			hires: false,

			/**
			 * Check if the specified media query name is on
			 * @param string name the name of the media query
			 * @return boolean true if on, else false
			 */
			has: function(name)
			{
				return ($.inArray(name, $.template.mediaQuery.on) > -1);
			},

			/**
			 * Check if the specified media query name is the current
			 * @param string name the name of the media query
			 * @return boolean true if on, else false
			 */
			is: function(name)
			{
				return ($.template.mediaQuery.name.indexOf(name.toLowerCase()) === 0);
			},

			/**
			 * Check if the current media query is smaller than the specified one
			 * @param string name the name of the media query
			 * @return boolean true if smaller, false if same or bigger
			 */
			isSmallerThan: function(name)
			{
				return !$.template.mediaQuery.has(name);
			}

		},

		/*
		 * Quick detection for IE7/8, because it requires several special behavors
		 * Yeah I know, browser sniffing is bad...
		 */
		ie7: !!(document.all && !document.querySelector),
		ie8: !!(document.all && document.querySelector && !document.getElementsByClassName),

		/*
		 * Infos about client browser
		 */
		iPhone:		!!navigator.userAgent.match(/iPhone/i),
		iPod:		!!navigator.userAgent.match(/iPod/i),
		iPad:		!!navigator.userAgent.match(/iPad/i),
		android:	!!navigator.userAgent.match(/Android/i)
	};

	// Post-processing
	$.template.iOs =		($.template.iPhone || $.template.iPod || $.template.iPad);
	$.template.touchOs =	($.template.iOs || $.template.android);

	// Normalized viewport size
	$.template.viewportWidth = win.width();
	$.template.viewportHeight = $.template.iPhone ? window.innerHeight : win.height();


	/********************************************************/
	/*                 3. Features detection                */
	/********************************************************/

	/*
	 * Respond.js v1.1.0rc1: min/max-width media query polyfill
	 * (c) Scott Jehl
	 * MIT/GPLv2 Lic
	 * j.mp/respondjs
	 *
	 * Important: the bundled version is slightly modded. Using another version may break compatibility for older browsers.
	 * See the file for more details.
	 */
	yepnope({
		test : Modernizr.mq('(min-width:0)'),
		nope : [$.template.respondPath+'respond.min.js']
	});


	/********************************************************/
	/*                 4. Touch optimization                */
	/********************************************************/

	/*
	 * Basic detection of touchmove events
	 * This allows to test on a 'touchend' event whether the 'touchmove' event was fired
	 * since 'touchstart'
	 */
	if (Modernizr.touch)
	{
		// Listen
		doc.on('touchstart', function(event)
		{
			touchMoved = false;
			++touchId;

		}).on('touchmove', function(event)
		{
			touchMoved = true;
		});
	}

	/**
	 * Function to determine if a touch-screen event (either touch or click) should be processed:
	 * - if this is a 'touchend' event, it checks if there was no 'touchmove' event since last 'touchstart'
	 * - if this is a 'click' event, it checks if the above 'touchend' event was not used
	 * @param DOM target the element on which the event is handled (not necessarily the event target)
	 * @param object event the fired event
	 * @return boolean return true if the event should be processed, else false
	 */
	$.template.processTouchClick = function(target, event)
	{
		// Missing param
		if (!event)
		{
			return true;
		}

		// Event type
		if (event.type === 'touchend')
		{
			// If no move was detected
			if (!touchMoved)
			{
				// Store last touchstart ID for later 'click' event
				$(target).data('touchstart-ID', touchId);

				// Valid event
				return true;
			}
			else
			{
				return false;
			}
		}
		else if (event.type === 'click')
		{
			// If a 'touchend' event was called on the same target since last 'touchstart'
			if ($(target).data('touchstart-ID') === touchId)
			{
				// Already processed
				return false;
			}
			else
			{
				return true;
			}
		}

		// Unknown type
		return true;
	};


	/********************************************************/
	/*              5. Position: fixed polyfill             */
	/********************************************************/

	/*
	 * Position: fixed support
	 * Modernizr fails at detecting it, so we must use a custom detection: a fixed element is created, and on first
	 * scroll the script will check its position to see if it is really fixed or not.
	 */

	// Create element
	fixedTest = $('<div style="position:fixed; top:0"></div>').appendTo(bod);
	function _checkPositionFixed()
	{
		// Top position
		var top = fixedTest.offset().top,
			scroll = doc.scrollTop();
		if (scroll < 2)
		{
			// Do not process if too small, it sometimes causes false positive
			return;
		}

		// Test
		if (Math.round(top) != Math.round(scroll))
		{
			// Define
			supportFixed = false;

			// Prepare already listed elements
			fixed.css({
				right: 'auto',
				bottom: 'auto'
			});

			// Fonction to fix positions
			var scrollFixed = function()
			{
				_setPositionFixed(fixed);
			};

			// First run
			scrollFixed();

			// Start watching
			doc.on('scroll', scrollFixed);
			win.on('normalized-resize orientationchange', scrollFixed);
		}

		// End detection
		fixedTest.remove();
		doc.off('scroll', _checkPositionFixed);
	}
	doc.on('scroll', _checkPositionFixed);

	/**
	 * Process an elements list and set correct fixed position
	 * @param jQuery elements the jQuery selection of elements
	 * @return void
	 */
	function _setPositionFixed(elements)
	{
		// Current scroll
		var scrollTop = doc.scrollTop(),
			scrollLeft = doc.scrollLeft(),
			width = $.template.viewportWidth,
			height = $.template.viewportHeight;

		// Fix elements
		elements.each(function(i)
		{
			var element = $(this),
				positions = element.data('fixed-position'),
				offsetTop, offsetLeft;

			if (positions.top)
			{
				offsetTop = positions.top.percentage ? positions.top.value*height : positions.top.value;
				element.css('top', (scrollTop+offsetTop)+'px');
			}
			if (positions.left)
			{
				offsetLeft = positions.left.percentage ? positions.left.value*width : positions.left.value;
				element.css('left', (scrollLeft+offsetLeft)+'px');
			}
			if (positions.right)
			{
				if (positions.left)
				{
					element.width(width-offsetLeft-(positions.right.percentage ? positions.right.value*width : positions.right.value));
				}
				else
				{
					element.css('left', (scrollLeft+(positions.right.percentage ? (1-positions.right.value)*width : width-positions.right.value)-element.outerWidth())+'px');
				}
			}
			if (positions.bottom)
			{
				if (positions.top)
				{
					element.height(height-offsetTop-(positions.bottom.percentage ? positions.bottom.value*height : positions.bottom.value));
				}
				else
				{
					element.css('top', (scrollTop+(positions.bottom.percentage ? (1-positions.bottom.value)*height : height-positions.bottom.value)-element.outerHeight())+'px');
				}
			}
		});
	}

	/**
	 * Detect an absolutely positioned element's bounds
	 */
	$.fn.detectFixedBounds = function()
	{
		// Prepare
		this.css({
			top: '',
			right: '',
			bottom: '',
			left: '',
			width: '',
			height: ''
		});

		// Detect
		this.each(function()
		{
			// Prepare
			var element = $(this),
				sides = ['top', 'right', 'bottom', 'left'],
				positions = {},
				i, value;

			// Parse positions
			for (i = 0; i < sides.length; ++i)
			{
				value = element.css(sides[i]);
				if (value.match(/^-?[0-9]+px$/))
				{
					positions[sides[i]] = { value: parseInt(value, 10), percentage: false };
				}
				else if (value.match(/^-?[0-9]+px$/))
				{
					positions[sides[i]] = { value: parseFloat(value)/100, percentage: true };
				}
			}

			// Default positions
			if (!positions.top && !positions.bottom)
			{
				positions.top = { value: 0, percentage: false };
			}
			if (!positions.left && !positions.right)
			{
				positions.left = { value: 0, percentage: false };
			}

			// Store
			element.data('fixed-position', positions);
		});

		// Fix if already detected
		if (!supportFixed)
		{
			// Set bottom and right to auto
			this.css({
				right: 'auto',
				bottom: 'auto'
			});

			// Update position
			_setPositionFixed(this);
		}

		return this;
	};

	/**
	 * Function to register an element whose position needs to be fixed
	 */
	$.fn.enableFixedFallback = function()
	{
		// Store original position
		fixed = fixed.add(this.detectFixedBounds());
	};

	/**
	 * Function to remove an element whose position does not need anymore to be fixed
	 */
	$.fn.disableFixedFallback = function()
	{
		// Clean
		this.css({
			top: '',
			right: '',
			bottom: '',
			left: '',
			width: '',
			height: ''
		});

		// Remove
		fixed = fixed.not(this.removeData('fixed-position'));
	};

	/********************************************************/
	/*                 6. Generic functions                 */
	/********************************************************/

	/**
	 * Parse a css numeric value
	 *
	 * @param jQuery element the element whose property to parse
	 * @param string prop the name of the property
	 * @param int def the default value if parsing fails (default: 0)
	 * @return the parsed css value, or def
	 */
	$.fn.parseCSSValue = function(prop, def)
	{
		var parsed = parseInt(this.css(prop), 10);
		return isNaN(parsed) ? (def || 0) : parsed;
	};

	/**
	 * Test if an element has an inline CSS property set
	 *
	 * @param string prop the name of the property
	 * @return boolean true if set, else false
	 */
	$.fn.hasInlineCSS = function(prop)
	{
		// If empty
		if (this.length === 0)
		{
			return false;
		}

		var regex = new RegExp('(^| |\t|;)'+prop+'\s*:', 'i');
		return regex.test(this.getStyleString());
	};

	/**
	 * Return the element inline style string
	 * Note: for IE, the node.style.cssText is not raw, but as parsed by the browser (http://javascript.gakaa.com/style-csstext.aspx)
	 *
	 * @return string the style string
	 * @url http://stackoverflow.com/questions/4233273/howto-get-cross-browser-literal-style-string-with-javascript
	 */
	$.fn.getStyleString = function()
	{
		if (this.length === 0)
		{
			return '';
		}
		var string = !$.support.style ? this[0].style.cssText.toLowerCase() : this[0].getAttribute('style');
		return (string || '');
	};

	/**
	 * Get immediate siblings matching a selector at the beginning of a selection:
	 * The filter stops as soon as non-matching node is found
	 *
	 * @param string selector any jQuery selector string
	 * @param boolean fromLast use true to filter from the last element (default: false)
	 * @return the matching immediate siblings
	 */
	$.fn.filterFollowing = function(selector, fromLast)
	{
		// Build selection
		var selection = $(),
			next;

		// If no selector or no elements, no need to process
		if (!selector || selector === '')
		{
			return selection.add(this);
		}
		else if (this.length === 0)
		{
			return selection;
		}

		// Run through selection
		next = this[fromLast ? 'last' : 'first']();
		while (next.is(selector))
		{
			selection = selection.add(next);
			next = next[fromLast ? 'prev' : 'next']();
		}

		return selection;
	};

	/**
	 * Get immediate previous siblings matching a selector
	 * Different from prevAll() as it stops as soon as non-matching node is found
	 *
	 * @param string selector any jQuery selector string
	 * @return the matching immediate previous siblings
	 */
	$.fn.prevImmediates = function(selector)
	{
		return this.prevAll().filterFollowing(selector);
	};

	/**
	 * Get immediate next siblings matching a selector
	 * Different from nextAll() as it stops as soon as non-matching node is found
	 *
	 * @param string selector any jQuery selector string
	 * @return the matching immediate next siblings
	 */
	$.fn.nextImmediates = function(selector)
	{
		return this.nextAll().filterFollowing(selector);
	};

	/**
	 * Get immediate children siblings matching a selector
	 * Different from nextAll() as it stops as soon as non-matching node is found
	 *
	 * @param string selector any jQuery selector string
	 * @param boolean fromLast use true to filter from the last element (default: false)
	 * @return the matching immediate next siblings
	 */
	$.fn.childrenImmediates = function(selector, fromLast)
	{
		return this.children().filterFollowing(selector, fromLast);
	};

	/**
	 * Temporary show the element and its parents (use tempShowRevert() to revert to original style)
	 * @return the list of affected elements
	 */
	$.fn.tempShow = function()
	{
		// List of affected elements
		var affected = $();

		// Elements themselves
		this.each(function(i)
		{
			var element = $(this);

			// If the element is hidden
			if (element.css('display') === 'none')
			{
				affected = affected.add(element.show());
			}

			// Parents
			element.parentsUntil('body').each(function()
			{
				var parent = $(this),
					added = false;

				// If the element is hidden
				if (parent.css('display') === 'none')
				{
					affected = affected.add(parent.show());
					added = true;
				}

				// Special case for details content wrapper
				if (this.nodeName.toLowerCase() === 'details' && !this.open)
				{
					// Force open
					parent.prop('open', true).data('tempShowDetails', true);

					// Add to selection if needed
					if (!added)
					{
						affected = affected.add(parent);
					}
				}

				// Next round
				previous = parent;
			});
		});

		return affected;
	};

	/**
	 * Revert elements affected by tempShow() to their orignal state
	 */
	$.fn.tempShowRevert = function()
	{
		// Try to use defaut style, then check for elements that require inline style
		return this.css('display', '').each(function(i)
		{
			var element = $(this);

			// If still not hidden
			if (element.css('display') !== 'none' && !element.data('tempShowDetails'))
			{
				element.css('display', 'none');
			}

			// Special case for details content wrapper
			if (this.nodeName.toLowerCase() === 'details' && element.data('tempShowDetails'))
			{
				// Close again
				element.prop('open', false).removeData('tempShowDetails');
			}
		});
	};

	/********************************************************/
	/*                    7. Custom events                  */
	/********************************************************/

	/*
	 * The sizechange event is fired everytime an object size changes.
	 * The scrollsizechange event is a special event designed to fire when
	 * scrollWidth or scrollHeight change
	 */

	/**
	 * Object to handle the sizechange/scrollsizechange vars
	 * @var object
	 */
	var sizeWatcher = {

		/**
		 * List of elements being watched for the sizechange event
		 * @var jQuery
		 */
		sizeElements: $(),

		/**
		 * List of elements being watched for the widthchange event
		 * @var jQuery
		 */
		widthElements: $(),

		/**
		 * List of elements being watched for the heightchange event
		 * @var jQuery
		 */
		heightElements: $(),

		/**
		 * List of elements being watched for the scrollsizechange event
		 * @var jQuery
		 */
		scrollElements: $(),

		/**
		 * Check interval length, in milliseconds
		 * @var int
		 */
		interval: 250,

		/**
		 * Storage for the timeout id
		 * @var int|boolean
		 */
		timeout: false,

		/**
		 * Function checking each element scroll sizes
		 * @var function
		 */
		watch: function()
		{
			// Check elements
			if ($.isReady)
			{
				// Size check
				sizeWatcher.sizeElements.each(function(i)
				{
					var element = $(this),
						width = element.width(),
						height = element.height(),
						data = element.data('sizecache') || { width: 0, height: 0 };

					// If different
					if (width != data.width || height != data.height)
					{
						// Update data
						element.data('sizecache', {
							width: width,
							height: height
						});

						// Fire event
						element.trigger('sizechange', [width != data.width, height != data.height]);
					}
				});

				// Width check
				sizeWatcher.widthElements.each(function(i)
				{
					var element = $(this),
						width = element.width(),
						data = element.data('widthcache') || 0;

					// If different
					if (width != data)
					{
						// Update data
						element.data('widthcache', width);

						// Fire event
						element.trigger('widthchange', [width]);
					}
				});

				// Height check
				sizeWatcher.heightElements.each(function(i)
				{
					var element = $(this),
						height = element.height(),
						data = element.data('heightcache') || 0;

					// If different
					if (height != data)
					{
						// Update data
						element.data('heightcache', height);

						// Fire event
						element.trigger('heightchange', [height]);
					}
				});

				// Scroll size check
				sizeWatcher.scrollElements.each(function(i)
				{
					var element = $(this),
						width = this.scrollWidth,
						height = this.scrollHeight,
						data = element.data('scrollcache') || { width: 0, height: 0 };

					// If different
					if (width != data.width || height != data.height)
					{
						// Update data
						element.data('scrollcache', {
							width: width,
							height: height
						});

						// Fire event
						element.trigger('scrollsizechange', [width != data.width, height != data.height]);
					}
				});
			}

			// Next check
			sizeWatcher.timeout = setTimeout(sizeWatcher.watch, sizeWatcher.interval);
		},

		/**
		 * Start the watcher if needed
		 * @var function
		 */
		start: function()
		{
			// If not watching yet, start
			if (!sizeWatcher.timeout)
			{
				sizeWatcher.timeout = setTimeout(sizeWatcher.watch, sizeWatcher.interval);
			}
		},

		/**
		 * Stop the watcher if needed
		 * @var function
		 */
		stop: function()
		{
			// If no more elements are being watched, stop
			if (sizeWatcher.sizeElements.length === 0 && sizeWatcher.widthElements.length === 0 &&
				sizeWatcher.heightElements.length === 0 && sizeWatcher.scrollElements.length === 0)
			{
				clearTimeout(sizeWatcher.timeout);
				sizeWatcher.timeout = false;
			}
		}

	};

	// Define size change custom event
	$.event.special.sizechange = {

		/**
		 * This method gets called the first time the event is bound to an element.
		 */
		setup: function()
		{
			var element = $(this);

			// Store scroll sizes
			element.data('sizecache', {
				width: element.width(),
				height: element.height()
			});

			// Add element to watched list
			sizeWatcher.sizeElements = sizeWatcher.sizeElements.add(this);

			// Start watcher
			sizeWatcher.start();
		},

		/**
		 * This method gets called when the event is unbound from an element.
		 */
		teardown: function()
		{
			// Remove from watched list
			sizeWatcher.sizeElements = sizeWatcher.sizeElements.not(this);

			// Clear data
			$(this).removeData('sizecache');

			// Stop watcher
			sizeWatcher.stop();
		}

	};

	// Define width change custom event
	$.event.special.widthchange = {

		/**
		 * This method gets called the first time the event is bound to an element.
		 */
		setup: function()
		{
			var element = $(this);

			// Store scroll sizes
			element.data('widthcache', element.width());

			// Add element to watched list
			sizeWatcher.widthElements = sizeWatcher.widthElements.add(this);

			// Start watcher
			sizeWatcher.start();
		},

		/**
		 * This method gets called when the event is unbound from an element.
		 */
		teardown: function()
		{
			// Remove from watched list
			sizeWatcher.widthElements = sizeWatcher.widthElements.not(this);

			// Clear data
			$(this).removeData('widthcache');

			// Stop watcher
			sizeWatcher.stop();
		}

	};

	// Define height change custom event
	$.event.special.heightchange = {

		/**
		 * This method gets called the first time the event is bound to an element.
		 */
		setup: function()
		{
			var element = $(this);

			// Store scroll sizes
			element.data('heightcache', element.height());

			// Add element to watched list
			sizeWatcher.heightElements = sizeWatcher.heightElements.add(this);

			// Start watcher
			sizeWatcher.start();
		},

		/**
		 * This method gets called when the event is unbound from an element.
		 */
		teardown: function()
		{
			// Remove from watched list
			sizeWatcher.heightElements = sizeWatcher.heightElements.not(this);

			// Clear data
			$(this).removeData('heightcache');

			// Stop watcher
			sizeWatcher.stop();
		}

	};

	// Define scroll change custom event
	$.event.special.scrollsizechange = {

		/**
		 * This method gets called the first time the event is bound to an element.
		 */
		setup: function()
		{
			// Store scroll sizes
			$(this).data('scrollcache', {
				width: this.scrollWidth,
				height: this.scrollHeight
			});

			// Add element to watched list
			sizeWatcher.scrollElements = sizeWatcher.scrollElements.add(this);

			// Start watcher
			sizeWatcher.start();
		},

		/**
		 * This method gets called when the event is unbound from an element.
		 */
		teardown: function()
		{
			// Remove from watched list
			sizeWatcher.scrollElements = sizeWatcher.scrollElements.not(this);

			// Clear data
			$(this).removeData('scrollcache');

			// Stop watcher
			sizeWatcher.stop();
		}
	};

	/**
	 * Helper for sizechange event
	 * @param function fn a function to bind to the event, or nothing just to trigger the event
	 */
	$.fn.sizechange = function(fn)
	{
		return (typeof fn === 'function') ? this.on('sizechange', fn) : this.trigger('sizechange');
	};

	/**
	 * Helper for widthchange event
	 * @param function fn a function to bind to the event, or nothing just to trigger the event
	 */
	$.fn.widthchange = function(fn)
	{
		return (typeof fn === 'function') ? this.on('widthchange', fn) : this.trigger('widthchange');
	};

	/**
	 * Helper for heightchange event
	 * @param function fn a function to bind to the event, or nothing just to trigger the event
	 */
	$.fn.heightchange = function(fn)
	{
		return (typeof fn === 'function') ? this.on('heightchange', fn) : this.trigger('heightchange');
	};

	/**
	 * Helper for scrollsizechange event
	 * @param function fn a function to bind to the event, or nothing just to trigger the event
	 */
	$.fn.scrollsizechange = function(fn)
	{
		return (typeof fn === 'function') ? this.on('scrollsizechange', fn) : this.trigger('scrollsizechange');
	};

	/********************************************************/
	/*               8. DOM watching functions              */
	/********************************************************/

	/*
	 * The template has to perform some transformations on any inserted/modified/remove content, so we intercept main
	 * jQuery DOM methods to add a callback to the setup/clear functions.
	 *
	 * This feature is designed so developers won't need to call applySetup and applyClear functions everytime they change the DOM.
	 *
	 * On heavy applications, this may lead to some performance loss, so this feature can be disabled on demand.
	 */
	$.each([

		/*
		 * Each function can have a clear and a setup function
		 * Both can take several options:
		 * - prepare (setup only): if required, perform an initial selection to detect which elements are added/removed
		 * - target: function that returns the target of the clear/setup functions
		 * - self: whether the clear/setup functions should apply to the modified elements
		 * - subs: whether the clear/setup functions should apply to the modified elements children
		 */
		{
			name:	'wrapAll',
			clear:	false,
			setup:	{ prepare: false,
					target: function() { return this.parent(); },
					self: true, subs: false }
		},
		{
			name:	'wrapInner',
			clear:	false,
			setup:	{ prepare: false,
					target: function() { return this.children(); },
					self: true, subs: false }
		},
		{
			name:	'wrap',
			clear:	false,
			setup:	{ prepare: false,
					target: function() { return this.parent(); },
					self: true, subs: false }
		},
		{
			name:	'unwrap',
			clear:	{ target: function() { return this.parent(); },
					self: true, subs: false },
			setup:	false
		},
		{
			name:	'append',
			clear:	false,
			setup:	{ prepare: function() { return this.children(); },
					target: function(prepared) { return this.children().not(prepared); },
					self: true, subs: true }
		},
		{
			name:	'prepend',
			clear:	false,
			setup:	{ prepare: function() { return this.children(); },
					target: function(prepared) { return this.children().not(prepared); },
					self: true, subs: true }
		},
		{
			name:	'before',
			clear:	false,
			setup:	{ prepare: function() { return this.prevAll(); },
					target: function(prepared) { return this.prevAll().not(prepared); },
					self: true, subs: true }
		},
		{
			name:	'after',
			clear:	false,
			setup:	{ prepare: function() { return this.nextAll(); },
					target: function(prepared) { return this.nextAll().not(prepared); },
					self: true, subs: true }
		},
		{
			name:	'remove',
			clear:	{ target: function() { return this; },
					self: true, subs: true },
			setup:	false
		},
		{
			name:	'empty',
			clear:	{ target: function() { return this; },
					self: false, subs: true },
			setup:	false
		},
		{
			name:	'html',
			clear:	{ target: function() { return this; },
					self: false, subs: true },
			setup:	{ prepare: false,
					target: function() { return this; },
					self: true,  subs: false }
		}

	], function()
	{
		// Store original
		var func = this,
			original = $.fn[func.name];

		// New wrapper function
		$.fn[func.name] = function()
		{
			var target,
				prepared = false,
				result;

			if (autoWatch && watching)
			{
				// Clear dynamic elements
				if (func.clear)
				{
					func.clear.target.call(this).applyClear(func.clear.self, func.clear.sub);
				}

				// Preparation for setup
				if (func.setup && func.setup.prepare)
				{
					prepared = func.setup.prepare.call(this);
				}
			}

			// Call original
			watching = false;
			result = original.apply(this, Array.prototype.slice.call(arguments));
			watching = true;

			// Call template setup
			if (autoWatch && watching && func.setup)
			{
				func.setup.target.call(this, prepared).applySetup(func.setup.self, func.setup.sub);
			}

			return result;
		};
	});

	/**
	 * Enable DOM watching
	 * @return void
	 */
	$.template.enableDOMWatch = function()
	{
		autoWatch = true;
	};

	/**
	 * Disable DOM watching
	 * @return boolean whether DOM watching was activated before
	 */
	$.template.disableDOMWatch = function()
	{
		var previous = autoWatch;
		autoWatch = false;
		return previous;
	};

	/********************************************************/
	/*              9. Template setup functions             */
	/********************************************************/

	/**
	 * Add a new global clear function. The function should accept 2 arguments:
	 * - self (whether the target element should be affected or not)
	 * - children (whether the element's children should be affected or not)
	 * The function should also return the jQuery selection, incremented from any added element in the root set
	 * (Note: the function may use the custom method findIn() with the same arguments)
	 *
	 * @param function func the function to be called on a jQuery object
	 * @param boolean priority set to true to call the function before all others (optional, default false)
	 * @return void
	 */
	$.template.addClearFunction = function(func, priority)
	{
		clearFunctions[priority ? 'unshift' : 'push'](func);
	};

	/**
	 * Add a clear function on an element, with same format as $.template.addClearFunction()
	 * This function is primarily intended for removing template replacement elements,
	 * but may be used for any other purpose
	 *
	 * @param function func the function to be added
	 * @param boolean priority set to true to call the function before all others (optional)
	 */
	$.fn.addClearFunction = function(func, priority)
	{
		this.each(function(i)
		{
			var element = $(this),
			functions = element.data('clearFunctions') || [];
			if (!functions.length || $.inArray(func, functions) < 0)
			{
				functions[priority ? 'unshift' : 'push'](func);
				element.addClass('withClearFunctions').data('clearFunctions', functions);
			}
		});

		return this;
	};

	/**
	 * Remove a clear function from the element
	 *
	 * @param function func the function to be cleared
	 */
	$.fn.removeClearFunction = function(func)
	{
		this.each(function()
		{
			var element = $(this),
				functions = element.data('clearFunctions') || [],
				i;

			// Clear
			for (i = 0; i < functions.length; ++i)
			{
				if (functions[i] === func)
				{
					functions.splice(i, 1);
					--i;
				}
			}

			// If any function left
			if (functions.length > 0)
			{
				element.data('clearFunctions', functions);
			}
			else
			{
				element.removeClass('withClearFunctions').removeData('clearFunctions');
			}
		});

		return this;
	};

	/**
	 * Call every clear function over a jQuery object (for instance : $('body').applyClear())
	 *
	 * @param boolean self whether the current element should be affected or not (default: true)
	 * @param boolean children whether the element's children should be affected or not (default: true)
	 */
	$.fn.applyClear = function(self, children)
	{
		var element = this,
			isWatching = $.template.disableDOMWatch();

		// Defaults
		if (self === undefined) self = true;
		if (children === undefined) children = true;

		$.each(clearFunctions, function()
		{
			element = this.call(element, self, children);
		});

		// Re-enable DOM watching if required
		if (isWatching)
		{
			$.template.enableDOMWatch();
		}

		return this;
	};

	/**
	 * Add a new global setup function. The function should accept 2 arguments:
	 * - self (whether the current element should be affected or not)
	 * - children (whether the element's children should be affected or not)
	 * The function should also return the jQuery selection, incremented from any added element in the root set
	 * (Note: the function may use the custom method findIn() with the same arguments)
	 *
	 * @param function func the function to be called on a jQuery object
	 * @param boolean priority set to true to call the function before all others (optional, default false)
	 * @return void
	 */
	$.template.addSetupFunction = function(func, priority)
	{
		setupFunctions[priority ? 'unshift' : 'push'](func);
	};

	/**
	 * Call every template setup function over a jQuery object (for instance : $('body').applySetup())
	 *
	 * @param boolean self whether the current element should be affected or not (default: true)
	 * @param boolean children whether the element's children should be affected or not (default: true)
	 */
	$.fn.applySetup = function(self, children)
	{
		var element = this,
			isWatching = $.template.disableDOMWatch();

		// Defaults
		if (self === undefined) self = true;
		if (children === undefined) children = true;

		$.each(setupFunctions, function()
		{
			this.call(element, self, children);
		});

		// Re-enable DOM watching if required
		if (isWatching)
		{
			$.template.enableDOMWatch();
		}

		return this;
	};

	/**
	 * Custom find method to work with the clear/setup functions arguments self & children
	 * @param boolean self whether the current element should be included in the search or not
	 * @param boolean children whether the element's children should be in the search or not
	 * @param mixed selector any selector for jQuery's find() method
	 * @return the selection
	 */
	$.fn.findIn = function(self, children, selector)
	{
		var element = $(this);

		// Mode
		if (self && children)
		{
			return element.filter(selector).add(element.find(selector));
		}
		else
		{
			return element[self ? 'filter' : 'find'](selector);
		}
	};

	/********************************************************/
	/*                  10. Template setup                  */
	/********************************************************/

	// Main template setup function
	$.template.addSetupFunction(function(self, children)
	{
		// Details polyfill (only if loaded)
		if ($.fn.details)
		{
			this.findIn(self, children, 'details').details();
		}

		// Icons polyfill
		if ($('html').hasClass('no-generatedcontent'))
		{
			// Icons replacement map
			var iconMap = {
				'plus': '&#59414;',
				'minus': '&#59417;',
				'info': '&#59422;',
				'left-thin': '&#59532;',
				'up-thin': '&#59534;',
				'right-thin': '&#59533;',
				'down-thin': '&#59531;',
				'level-up': '&#59539;',
				'level-down': '&#59538;',
				'switch': '&#59542;',
				'infinity': '&#59586;',
				'squared-plus': '&#59416;',
				'squared-minus': '&#59419;',
				'home': '&#59425;',
				'keyboard': '&#59450;',
				'erase': '&#59587;',
				'pause': '&#59545;',
				'forward': '&#59442;',
				'backward': '&#59550;',
				'next': '&#59547;',
				'previous': '&#59548;',
				'hourglass': '&#59491;',
				'stop': '&#59544;',
				'triangle-up': '&#59526;',
				'play': '&#59543;',
				'triangle-right': '&#59525;',
				'triangle-down': '&#59523;',
				'triangle-left': '&#59524;',
				'adjust': '&#59495;',
				'cloud': '&#59570;',
				'star': '&#59400;',
				'star-empty': '&#59401;',
				'cup': '&#59462;',
				'list': '&#59409;',
				'moon': '&#59573;',
				'heart-empty': '&#59399;',
				'heart': '&#59398;',
				'music-note': '&#59392;',
				'beamed-note': '&#59393;',
				'thumbs': '&#59408;',
				'flag': '&#59434;',
				'tools': '&#59478;',
				'gear': '&#59477;',
				'warning': '&#59454;',
				'lightning': '&#59572;',
				'record': '&#59546;',
				'thunder-cloud': '&#59571;',
				'voicemail': '&#59592;',
				'plane': '&#59574;',
				'mail': '&#59397;',
				'pencil': '&#59446;',
				'feather': '&#59447;',
				'tick': '&#59410;',
				'cross': '&#59411;',
				'cross-round': '&#59412;',
				'squared-cross': '&#59413;',
				'question': '&#59420;',
				'quote': '&#59443;',
				'plus-round': '&#59415;',
				'minus-round': '&#59418;',
				'right': '&#59521;',
				'arrow': '&#59460;',
				'fwd': '&#59549;',
				'undo': '&#59535;',
				'redo': '&#59536;',
				'left': '&#59520;',
				'up': '&#59522;',
				'down': '&#59519;',
				'list-add': '&#59558;',
				'numbered-list': '&#59557;',
				'left-fat': '&#59528;',
				'right-fat': '&#59529;',
				'up-fat': '&#59530;',
				'down-fat': '&#59527;',
				'add-user': '&#59404;',
				'question-round': '&#59421;',
				'info-round': '&#59423;',
				'eye': '&#59430;',
				'price-tag': '&#59578;',
				'cloud-upload': '&#59439;',
				'reply': '&#59440;',
				'reply-all': '&#59441;',
				'code': '&#59444;',
				'extract': '&#59445;',
				'printer': '&#59448;',
				'refresh': '&#59449;',
				'speech': '&#59451;',
				'chat': '&#59452;',
				'card': '&#59456;',
				'directions': '&#59457;',
				'marker': '&#59458;',
				'map': '&#59459;',
				'compass': '&#59461;',
				'trash': '&#59463;',
				'page': '&#59464;',
				'page-list-inverted': '&#59468;',
				'pages': '&#59465;',
				'frame': '&#59466;',
				'drawer': '&#59473;',
				'rss': '&#59475;',
				'path': '&#59479;',
				'cart': '&#59481;',
				'shareable': '&#59480;',
				'login': '&#59484;',
				'logout': '&#59485;',
				'volume': '&#59489;',
				'expand': '&#59497;',
				'reduce': '&#59498;',
				'new-tab': '&#59499;',
				'publish': '&#59500;',
				'browser': '&#59501;',
				'arrow-combo': '&#59502;',
				'pie-chart': '&#59588;',
				'language': '&#59594;',
				'air': '&#59598;',
				'database': '&#59603;',
				'drive': '&#59604;',
				'bucket': '&#59605;',
				'thermometer': '&#59606;',
				'down-round': '&#59503;',
				'left-round': '&#59504;',
				'right-round': '&#59505;',
				'up-round': '&#59506;',
				'chevron-down': '&#59507;',
				'chevron-left': '&#59508;',
				'chevron-right': '&#59509;',
				'chevron-up': '&#59510;',
				'chevron-small-down': '&#59511;',
				'chevron-small-left': '&#59512;',
				'chevron-small-right': '&#59513;',
				'chevron-small-up': '&#59514;',
				'chevron-thin-down': '&#59515;',
				'chevron-thin-left': '&#59516;',
				'chevron-thin-right': '&#59517;',
				'chevron-thin-up': '&#59518;',
				'progress-0': '&#59551;',
				'progress-1': '&#59552;',
				'progress-2': '&#59553;',
				'progress-3': '&#59554;',
				'back-in-time': '&#59562;',
				'network': '&#59565;',
				'mailbox': '&#59568;',
				'download': '&#59437;',
				'buoy': '&#59577;',
				'tag': '&#59431;',
				'dot': '&#59581;',
				'two-dots': '&#59582;',
				'ellipsis': '&#59583;',
				'suitcase': '&#59580;',
				'flow-cascade': '&#59608;',
				'flow-branch': '&#59609;',
				'flow-tree': '&#59610;',
				'flow-line': '&#59611;',
				'flow-parallel': '&#59612;',
				'brush': '&#59584;',
				'paper-plane': '&#59575;',
				'magnet': '&#59585;',
				'gauge': '&#59614;',
				'traffic-cone': '&#59615;',
				'creative-commons': '&#59616;',
				'cc-by': '&#59617;',
				'cc-nc': '&#59618;',
				'cc-nc-eu': '&#59619;',
				'cc-nc-jp': '&#59620;',
				'cc-sa': '&#59621;',
				'cc-nd': '&#59622;',
				'cc-pd': '&#59623;',
				'cc-zero': '&#59624;',
				'cc-share': '&#59625;',
				'cc-remix': '&#59626;',
				'github': '&#59627;',
				'github-circled': '&#59628;',
				'flickr': '&#59629;',
				'flickr-circled': '&#59630;',
				'vimeo': '&#59631;',
				'vimeo-circled': '&#59632;',
				'twitter': '&#59633;',
				'twitter-circled': '&#59634;',
				'facebook': '&#59635;',
				'facebook-circled': '&#59636;',
				'facebook-squared': '&#59637;',
				'gplus': '&#59638;',
				'gplus-circled': '&#59639;',
				'pinterest': '&#59640;',
				'pinterest-circled': '&#59641;',
				'tumblr': '&#59642;',
				'tumblr-circled': '&#59643;',
				'linkedin': '&#59644;',
				'linkedin-circled': '&#59645;',
				'dribbble': '&#59646;',
				'dribbble-circled': '&#59647;',
				'stumbleupon': '&#59648;',
				'stumbleupon-circled': '&#59649;',
				'lastfm': '&#59650;',
				'lastfm-circled': '&#59651;',
				'rdio': '&#59652;',
				'rdio-circled': '&#59653;',
				'spotify': '&#59654;',
				'spotify-circled': '&#59655;',
				'qq': '&#59656;',
				'instagram': '&#59657;',
				'dropbox': '&#59658;',
				'evernote': '&#59659;',
				'flattr': '&#59660;',
				'skype': '&#59661;',
				'skype-circled': '&#59662;',
				'renren': '&#59663;',
				'sina-weibo': '&#59664;',
				'paypal': '&#59665;',
				'picasa': '&#59666;',
				'soundcloud': '&#59667;',
				'mixi': '&#59668;',
				'behance': '&#59669;',
				'google-circles': '&#59670;',
				'vkontakte': '&#59671;',
				'smashing': '&#59672;',
				'db-shape': '&#59674;',
				'bullet-list': '&#59673;',
				'db-logo': '&#59675;',
				'pictures': '&#59406;',
				'globe': '&#59569;',
				'leaf': '&#59576;',
				'graduation-cap': '&#59593;',
				'mic': '&#59486;',
				'palette': '&#59556;',
				'ticket': '&#59595;',
				'movie': '&#59405;',
				'target': '&#59555;',
				'music': '&#59394;',
				'trophy': '&#59560;',
				'like': '&#59435;',
				'unlike': '&#59436;',
				'bag': '&#59482;',
				'user': '&#59402;',
				'users': '&#59403;',
				'light-bulb': '&#59492;',
				'new': '&#59455;',
				'water': '&#59596;',
				'droplet': '&#59597;',
				'credit-card': '&#59599;',
				'monitor': '&#59563;',
				'briefcase': '&#59579;',
				'save': '&#59600;',
				'cd': '&#59566;',
				'folder': '&#59472;',
				'page-list': '&#59467;',
				'calendar': '&#59483;',
				'line-graph': '&#59589;',
				'bar-graph': '&#59590;',
				'clipboard': '&#59601;',
				'paperclip': '&#59427;',
				'ribbons': '&#59433;',
				'book': '&#59471;',
				'read': '&#59470;',
				'phone': '&#59476;',
				'megaphone': '&#59602;',
				'outbox': '&#59438;',
				'inbox': '&#59567;',
				'box': '&#59474;',
				'newspaper': '&#59469;',
				'mobile': '&#59564;',
				'wifi': '&#59559;',
				'camera': '&#59407;',
				'swap': '&#59540;',
				'loop': '&#59541;',
				'cycle': '&#59537;',
				'light-down': '&#59493;',
				'light-up': '&#59494;',
				'mute': '&#59487;',
				'loud': '&#59488;',
				'battery': '&#59561;',
				'search': '&#59395;',
				'key': '&#59607;',
				'lock': '&#59428;',
				'unlock': '&#59429;',
				'bell': '&#59453;',
				'ribbon': '&#59432;',
				'link': '&#59426;',
				'revert': '&#59424;',
				'flashlight': '&#59396;',
				'area-graph': '&#59591;',
				'clock': '&#59490;',
				'rocket': '&#59613;',
				'forbidden': '&#59496;'
				};

			// Font-icons
			this.findIn(self, children, '[class^="icon-"],[class*=" icon-"]').not('.old-icon').each(function(i)
			{
				// Icon class
				var name = /icon-([^ ]+)/.exec(this.className)[1],
					element = $(this).addClass('old-icon');

				// If valid icon name
				if (iconMap[name])
				{
					// Remove existing icon
					element.children('.icon-font:first').remove();

					// Create replacement
					element.prepend('<span class="font-icon'+(element.is(':empty') ? ' empty' : '')+'">'+iconMap[name]+'</span>');
				}
			});
		}

		// IE7 support
		if ($.template.ie7)
		{
			// Before/after pseudo-elements
			var pseudo = {
					'.bullet-list > li':		{ before: '<span class="bullet-list-before">&#61456;</span>' },
					'.info-bubble':				{ before: '<span class="info-bubble-before"></span>' },
					'.select-arrow':			{ before: '<span class="select-arrow-before"></span>', after: '<span class="select-arrow-after"></span>' },
					'.with-left-arrow, .with-right-arrow, .tabs > li > a':
												{ after: '<span class="with-arrow-after"></span>' },
					'#menu':					{ before: '<span id="menu-before"></span>', after: '<span id="menu-after"></span>' },
					'.number-up, .number-down':	{ after: '<span class="number-after"></span>' }
				},

				// Target for other scopes
				target = this;

			// Last-child
			this.findIn(self, children, 'ul, li, dd, p, fieldset, .fieldset, button, .button, input, .input-info, .field-drop, .select, .loader').filter(':last-child').addClass('last-child');

			// Before/after pseudo-elements
			$.each(pseudo, function(key, value)
			{
				var elements = target.findIn(self, children, key);
				if (elements.length > 0)
				{
					// Before
					if (value.before)
					{
						elements.prepend(value.before);
					}

					// After
					if (value.after)
					{
						elements.append(value.after);
					}
				}
			});

			// Button-icons
			var buttonIcons = this.findIn(self, children, '.button-icon');
			buttonIcons.not('.right-side').parent().css('padding-left', '0px').css('border-left', '0');
			buttonIcons.filter('.right-side').before('&nbsp;&nbsp;').parent().css('padding-right', '0px').css('border-right', '0');

			// Buttons in inputs
			var buttons = this.findIn(self, children, '.input').children('.button').not('.compact');
			buttons.each(function(i)
			{
				if (!this.previousSibling)
				{
					$(this).parent().css('padding-left', '0px');
				}
				else if (!this.nextSibling)
				{
					$(this).parent().css('padding-right', '0px');
				}
			});

			// Vertical centered images
			this.findIn(self, children, '.icon > img, .stack, .controls > :first-child').before('<span class="vert-align">&nbsp;</span>');
		}

		// IE8 support
		if ($.template.ie8)
		{
			// Last-child
			this.findIn(self, children, 'ul, li, dd, p, fieldset, .fieldset, button, .button, input, .input-info, .field-drop, .select, .loader').filter(':last-child').addClass('last-child');

			// Font-icons
			this.findIn(self, children, '[class^="icon-"],[class*=" icon-"]').each(function(i)
			{
				// Empty elements
				var element = $(this);
				if (element.is(':empty'))
				{
					element.addClass('font-icon-empty');
				}
			});
		}

		return this;
	});

	// Main template clear function
	$.template.addClearFunction(function(self, children)
	{
		var elements = this;

		// Add replacement elements' targets
		if (self)
		{
			elements.filter('.replacement').each(function(i)
			{
				var replaced = $(this).data('replaced');
				if (replaced)
				{
					elements = elements.add(replaced);
				}
			});
		}

		// Tracking/tracked elements
		elements.findIn(self, children, '.tracking').stopTracking().remove();
		elements.findIn(self, children, '.tracked').getTrackers().stopTracking().remove();

		// Elements with clear functions
		elements.findIn(self, children, '.withClearFunctions').each(function(i)
		{
			var target = this,
				element = $(target),
				functions = element.data('clearFunctions') || [];

			$.each(functions, function(i)
			{
				this.apply(target);
			});

			// Once called, functions are removed
			element.removeClass('withClearFunctions').removeData('clearFunctions');
		});

		return elements;
	});


	/********************************************************/
	/*            11. Viewport resizing handling            */
	/********************************************************/

	/**
	 * Updates the current media query name and the list of activated media queries according to a test element
	 * @param boolean triggerEvents true to trigger events
	 * @return boolean true if the media query changed
	 */
	function _refreshMediaQueriesInfo(triggerEvents)
	{
		// Can't test if not ready
		if (!init)
		{
			return false;
		}

		// Create test element
		var isWatching = $.template.disableDOMWatch(),
			test = $('<div id="mediaquery-checker"></div>').appendTo(bod),
			width = test.width(),
			height = test.height(),
			previousName = $.template.mediaQuery.name,
			changed, previousGroup, newGroup;

		// Clean test element
		test.remove();

		// Re-enable DOM watching if required
		if (isWatching)
		{
			$.template.enableDOMWatch();
		}

		// Check list
		$.template.mediaQuery.on = [];
		$.each(mediaQueries, function(index, value)
		{
			// Add to currently on list
			$.template.mediaQuery.on.push(value[1]);

			// If found
			if (width <= value[0])
			{
				$.template.mediaQuery.name = value[1];
				return false;
			}
		});

		// Hires status
		$.template.mediaQuery.hires = (height >= hiresTestHeight);

		// Detect change
		changed = (previousName != $.template.mediaQuery.name);

		// Events
		if (changed && triggerEvents)
		{
			// Detect groups
			if (previousName.indexOf('-') > -1)
			{
				previousGroup = previousName.split('-').shift();
			}
			if ($.template.mediaQuery.name.indexOf('-') > -1)
			{
				newGroup = $.template.mediaQuery.name.split('-').shift();
			}

			// Quit previous mode
			doc.trigger('quit-query-'+previousName);

			// If changing group
			if (previousGroup && (!newGroup || newGroup != previousGroup))
			{
				// Quit previous group
				doc.trigger('quit-query-'+previousGroup);
			}

			// Change event
			doc.trigger('change-query');

			// If changing group
			if (newGroup && (!previousGroup || previousGroup != newGroup))
			{
				// Enter new group
				doc.trigger('enter-query-'+newGroup);
			}

			// Enter new mode
			doc.trigger('enter-query-'+$.template.mediaQuery.name);
		}

		return changed;
	}

	// Window resizing handling
	function handleResize()
	{
		// Normalized viewport size
		$.template.viewportWidth = win.width();
		$.template.viewportHeight = $.template.iPhone ? window.innerHeight : win.height();

		// Send normalized pre-resize event
		win.trigger('normalized-preresize');

		// Refresh media queries infos
		_refreshMediaQueriesInfo(true);

		// Tracked elements
		bod.refreshInnerTrackedElements();

		// Send normalized resize event
		win.trigger('normalized-resize');

		// Ready to listen again
		resizeInt = false;
	}
	win.on('resize', function()
	{
		// If not set, create a timeout to handle the resize event
		// This is required for some browsers sending this event too often
		if (!resizeInt && $.isReady)
		{
			resizeInt = setTimeout(handleResize, 40);
		}

	}).on('orientationchange', handleResize);

	// Listener for respond.js when all files have been parsed
	doc.on('respond-ready', function()
	{
		_refreshMediaQueriesInfo(true);
	});


	/********************************************************/
	/*                   12. Template init                  */
	/********************************************************/

	// Template init function
	$.template.init = function()
	{
			// Objects
		var menu = $('#menu'),
			menuContent = $('#menu-content'),

			// Used to handle fixed menu on mobiles
			previousScroll = false,

			// Function to watch menu size
			watchMenuSize;

		// If already inited
		if (init)
		{
			return;
		}

		// Template ready
		init = true;

		// Refresh media queries infos
		_refreshMediaQueriesInfo(false);

		// Initial setup
		bod.applySetup();

		// Init queries events
		doc.trigger('init-queries');

		// Trigger enter event
		doc.trigger('enter-query-'+$.template.mediaQuery.name);

		// Open/hide menu
		$('#open-menu').on('touchend click', function(event)
		{
			event.preventDefault();

			// Check if valid touch-click event
			if (!$.template.processTouchClick(this, event))
			{
				return;
			}

			// Close shortcuts
			bod.removeClass('shortcuts-open');

			// Se estiver no modo de tela ampla, mostre / esconda o menu lateral, caso contrrio, open / close o menu suspenso
			bod.toggleClass($.template.mediaQuery.is('desktop') || $.template.mediaQuery.is('tablet-landscape') ? 'menu-hidden' : 'menu-open');

			// If mobile layout, handle fixed title bar
			if ($.template.mediaQuery.is('mobile') && bod.hasClass('menu-open') && bod.hasClass('fixed-title-bar'))
			{
				// Store current scroll
				previousScroll = bod.scrollTop();

				// Remove fixed bar class
				bod.removeClass('fixed-title-bar');

				// Scroll to top
				bod.scrollTop(0);
			}
			else if (previousScroll !== false)
			{
				// Restore scroll
				if ($.template.mediaQuery.is('mobile'))
				{
					bod.scrollTop(previousScroll);
				}
				previousScroll = false;

				// Restore class
				bod.addClass('fixed-title-bar');
			}

			// Refresh drop-down menu size if needed
			watchMenuSize();
		});

		// Close drop-down menu
		bod.children().on('click', function(event)
		{
			// Check if open, and if the click is not on the menu or on the open button
			if (bod.hasClass('menu-open') && !$(event.target).closest('#open-menu, #menu').length)
			{
				// Fixed menu on mobile
				if (previousScroll !== false)
				{
					// Restore scroll
					if ($.template.mediaQuery.is('mobile'))
					{
						bod.scrollTop(previousScroll);
					}
					previousScroll = false;

					// Restore class
					bod.addClass('fixed-title-bar');
				}

				// Close menu
				bod.removeClass('menu-open');
			}
		});

		// Open/hide shortcuts
		$('#open-shortcuts').on('touchend click', function(event)
		{
			event.preventDefault();

			// Check if valid touch-click event
			if (!$.template.processTouchClick(this, event))
			{
				return;
			}

			// Fixed menu on mobile
			if (previousScroll !== false && bod.hasClass('menu-open'))
			{
				// Restore scroll
				if ($.template.mediaQuery.is('mobile'))
				{
					bod.scrollTop(previousScroll);
				}
				previousScroll = false;

				// Restore class
				bod.addClass('fixed-title-bar');
			}

			// Close menu and open shortcuts
			bod.removeClass('menu-open').toggleClass('shortcuts-open');
		});

		// When in tablet-portrait mode, we need to update the menu-content height manually
		watchMenuSize = function()
		{
			// Only works if drop-down menu is opened in tablet-portrait mode
			if (!bod.hasClass('menu-open') || !$.template.mediaQuery.is('tablet-portrait'))
			{
				menuContent.css('max-height', '');
				return;
			}

			var siblingsHeight = 0;

			// Get content siblings height
			menuContent.siblings().each(function(i)
			{
				siblingsHeight += $(this).outerHeight();
			});

			// Use available space (menu is 90% of viewport height)
			menuContent.css('max-height', (Math.round(0.9*$.template.viewportHeight)-(menu.outerHeight()-menu.height())-siblingsHeight)+'px');
		};

		// First call
		watchMenuSize();

		// Bind
		win.on('normalized-resize', watchMenuSize);

		// Custom scroll for menu (depends on media query)
		if ($.fn.customScroll)
		{
				// Current state
			var scrollMenu = false,
				scrollContent = false,

				// Handle media query changes
				updateMenuScroll = function()
				{
					// Mobile sizes
					if ($.template.mediaQuery.isSmallerThan('tablet-portrait'))
					{
						if (scrollMenu)
						{
							menu.removeCustomScroll();
							scrollMenu = false;
						}
						if (scrollContent)
						{
							menuContent.removeCustomScroll();
							scrollContent = false;
						}
					}
					// Tablet portrait
					else if ($.template.mediaQuery.is('tablet-portrait'))
					{
						if (scrollMenu)
						{
							menu.removeCustomScroll();
							scrollMenu = false;
						}
						if (!scrollContent)
						{
							menuContent.customScroll();
							scrollContent = true;
						}
					}
					// Tablet landscape and upper
					else
					{
						if (scrollContent)
						{
							menuContent.removeCustomScroll();
							scrollContent = false;
						}
						if (!scrollMenu)
						{
							menu.customScroll();
							scrollMenu = true;
						}
					}
				};

			// First call
			updateMenuScroll();

			// Bind
			doc.on('change-query', updateMenuScroll);
		}

		// Support for webapp mode on iOS
		if (('standalone' in window.navigator) && window.navigator.standalone)
		{
			doc.on('click', 'body', function (event)
			{
				var link = $(event.target).closest('a'),
					href;

				// Only handle links
				if (!link.length)
				{
					return;
				}

				// If already processed
				if (event.isDefaultPrevented())
				{
					return;
				}

				// Do not process local anchors
				href = link.attr('href');
				if (!href || href.indexOf('#') === 0)
				{
					return;
				}

				// Do not process if AJAX navigation link
				if (link.hasClass('navigable-ajax') || link.hasClass('navigable-ajax-loaded'))
				{
					return;
				}

				// Check target
				if (!(/^[a-z+\.\-]+:/i).test(href) || href.indexOf(document.location.protocol+'//'+document.location.host) === 0)
				{
					// Prevent link opening
					event.preventDefault();

					// Open inside the webapp
					document.location.href = href;
				}
			});
		}
	};

	// Initial setup
	doc.ready(function()
	{
		$.template.init();
	});

	/********************************************************/
	/*      13. Event delegation for template elements      */
	/********************************************************/

	/*
	 * Event delegation is used to handle most of the template setup, as it does also apply to dynamically added elements
	 * @see http://api.jquery.com/on/
	 */

	// Close buttons
	doc.on('click', '.close', function(event)
	{
		var close = $(this),
			parent = close.parent();

		event.preventDefault();

		close.remove();
		parent.addClass('closing').fadeAndRemove().trigger('close');
	});

	// Info bubbles
	if (Modernizr.touch)
	{
		doc.on('touchend', '.info-spot', function(event)
		{
			// Check if valid touch-click event
			if (!$.template.processTouchClick(this, event))
			{
				return;
			}

			var info = $(this),
				content = info.children('.info-bubble').html();

			// If any content is found
			if (content && content.length > 0)
			{
				event.preventDefault();

				// If the modal plugin is available
				if ($.modal)
				{
					$.modal.alert(content);
				}
				else
				{
					alert(content);
				}
			}
		});
	}
	else
	{
		// Check to see if the bubble need to open on another side to fit in the screen
		doc.on('mouseenter', '.info-spot', function(event)
		{
			var info = $(this),
				bubble = info.children('.info-bubble');

			// Check available space - horizontal
			if (info.hasClass('on-left'))
			{
				if (bubble.offset().left < 0)
				{
					info.removeClass('on-left')
						.data('info-spot-reverse-x', true);
				}
			}
			else
			{
				if (bubble.offset().left+bubble.outerWidth() > $.template.viewportWidth)
				{
					info.addClass('on-left')
						.data('info-spot-reverse-x', true);
				}
			}

			// Check available space - vertical
			if (info.hasClass('on-top'))
			{
				if (bubble.offset().top < doc.scrollTop())
				{
					info.removeClass('on-top')
						.data('info-spot-reverse-y', true);
				}
			}
			else
			{
				if (bubble.offset().top+bubble.outerHeight() > doc.scrollTop()+$.template.viewportHeight)
				{
					info.addClass('on-top')
						.data('info-spot-reverse-y', true);
				}
			}


		}).on('mouseleave', '.info-spot', function(event)
		{
			var info = $(this);

			// Check if reversed on open
			if (info.data('info-spot-reverse-x'))
			{
				info.toggleClass('on-left');
				info.removeData('info-spot-reverse-x');
			}
			if (info.data('info-spot-reverse-y'))
			{
				info.toggleClass('on-top');
				info.removeData('info-spot-reverse-y');
			}

		});
	}

	/*
	 * CSS pointerEvent polyfill for tooltips
	 * This snippet is from Lea Verou's CSS3 Secrets
	 * @url http://lea.verou.me/css3-secrets/
	 */
	if (!Modernizr.pointerevents)
	{
		doc.on('click mouseover', '.no-pointer-events', function (event)
		{
			// Hide element
			this.style.display = 'none';

			// Get element under cursor position
			var x = event.pageX, y = event.pageY,
				under = document.elementFromPoint(x, y);

			// Unhide
			this.style.display = '';

			// Proper event triggering
			event.stopPropagation();
			event.preventDefault();
			$(under).trigger(event.type);
		});
	}

	/********************************************************/
	/*                 14. Tracked elements                 */
	/********************************************************/

	/*
	 * Tracked elements methods add a convenient way of making an absolutely positioned follow an element in the document flow
	 * @param jquery element the jQuery object of the target element
	 */

	/**
	 * Make the current element track another element
	 *
	 * @param jQuery target the jQuery object of the target element
	 * @param function refreshFunc the function to refresh position (called with tracking element as 'this' and target as argument)
	 *								If none, the tracking element will be aligned with its target
	 */
	$.fn.trackElement = function(target, refreshFunc)
	{
		// Reduce selection if needed
		target = target.eq(0).addClass('tracked');

		// Function
		if (!refreshFunc)
		{
			refreshFunc = function(target) { $(this).offset(target.offset()); };
		}

		var targetDOM = target[0],
			tracking = target.data('tracking-elements') || [];

		this.css({ position:'absolute' }).addClass('tracking').each(function(i)
		{
			var element = $(this),
				tracked = element.data('tracked-element');

			// If already tracking but not the current target
			if (tracked && tracked !== targetDOM)
			{
				// Stop first
				element.stopTracking();
				tracked = null;
			}

			// If not already tracking target
			if (!tracked)
			{
				// Store references
				element.data('tracked-element', targetDOM);
				tracking.push({
					element: this,
					func: refreshFunc
				});

				// Make first call
				refreshFunc.call(this, target);
			}
		});

		// Update target
		target.data('tracking-elements', tracking);

		return this;
	};

	/**
	 * Stop a element from tracking
	 *
	 * @param boolean clearPos if true, will clean position styling (top & left)
	 */
	$.fn.stopTracking = function(clearPos)
	{
		// Remove
		this.each(function()
		{
			var element = $(this),
				tracked = element.data('tracked-element'),
				target, tracking, i;

			// If tracking
			if (tracked)
			{
				target = $(tracked);
				tracking = target.data('tracking-elements') || [];

				// Clear list from element
				for (i = 0; i < tracking.length; ++i)
				{
					if (tracking[i].element === this)
					{
						tracking.splice(i, 1);
						--i;
					}
				}

				// If no more elements are being watched, quit watching
				if (tracking.length === 0)
				{
					target.removeClass('tracked').removeData('tracking-elements');
				}
				else
				{
					target.data('tracking-elements', tracking);
				}

				// Clean data
				element.removeClass('tracking').removeData('tracked-element');

				// Clear position
				element.css({ position: '' });
				if (clearPos)
				{
					element.css({
						top: '',
						left: ''
					});
				}
			}
		});

		return this;
	};

	/**
	 * Updated tracking elements within selection
	 */
	$.fn.refreshTrackedElements = function()
	{
		this.filter('.tracked').each(function(i)
		{
			var target = $(this);
			$.each(target.data('tracking-elements') || [], function(i)
			{
				$(this.element).stop(true, true);
				if (this.func)
				{
					this.func.call(this.element, target);
				}
			});
		});

		return this;
	};

	// Tracked elements
	win.scroll(function()
	{
		bod.refreshInnerTrackedElements();
	});

	/**
	 * Update tracking elements in selection's inner elements
	 */
	$.fn.refreshInnerTrackedElements = function()
	{
		this.find('.tracked').each(function(i)
		{
			var target = $(this);
			$.each(target.data('tracking-elements') || [], function(i)
			{
				$(this.element).stop(true, true);
				if (this.func)
				{
					this.func.call(this.element, target);
				}
			});
		});

		return this;
	};

	/**
	 * Returns the jQuery list of tracking elements
	 */
	$.fn.getTrackers = function()
	{
		var list = [];
		$.each($(this).data('tracking-elements') || [], function(i)
		{
			list.push(this.element);
		});
		return $(list);
	};



	/********************************************************/
	/*                 15. Custom animations                */
	/********************************************************/

	/**
	 * Remove an element with folding effect
	 *
	 * @param string|int duration a string (fast, normal or slow) or a number of millisecond. Default: 'normal'. - optional
	 * @param function callback any function to call at the end of the effect. Default: none. - optional
	 */
	$.fn.foldAndRemove = function(duration, callback)
	{
		$(this).slideUp(duration, function()
		{
			// Callback function
			if (callback)
			{
				callback.apply(this);
			}

			$(this).remove();
		});

		return this;
	};

	/**
	 * Remove an element with fading then folding effect
	 *
	 * @param string|int duration a string (fast, normal or slow) or a number of millisecond. Default: 'normal'. - optional
	 * @param function callback any function to call at the end of the effect. Default: none. - optional
	 */
	$.fn.fadeAndRemove = function(duration, callback)
	{
		this.animate({'opacity': 0}, {
			'duration': duration,
			'complete': function()
			{
				var element = $(this).trigger('endfade');

				// No folding required if the element has position: absolute (not in the elements flow)
				if (element.css('position') == 'absolute')
				{
					// Callback function
					if (callback)
					{
						callback.apply(this);
					}

					element.remove();
				}
				else
				{
					element.slideUp(duration, function()
					{
						// Callback function
						if (callback)
						{
							callback.apply(this);
						}

						element.remove();
					});
				}
			}
		});

		return this;
	};

	/**
	 * Shake an element
	 * The jQuery UI's bounce effect messes with margins so let's build ours
	 *
	 * @param int force size (in pixels) of the movement (default: 15)
	 * @param function callback any function to call at the end of the effect. Default: none. - optional
	 */
	$.fn.shake = function(force, callback)
	{
		// Param check
		force = force || 15;

		this.each(function()
		{
			var element = $(this),

				// Initial margins
				leftMargin = element.parseCSSValue('margin-left'),
				rightMargin = element.parseCSSValue('margin-right'),

				// Force tweening
				steps = [
					force,
					Math.round(force*0.8),
					Math.round(force*0.6),
					Math.round(force*0.4),
					Math.round(force*0.2)
				],

				// Final range calculation
				effectMargins = [
					[leftMargin-steps[0], rightMargin+steps[0]],
					[leftMargin+steps[1], rightMargin-steps[1]],
					[leftMargin-steps[2], rightMargin+steps[2]],
					[leftMargin+steps[3], rightMargin-steps[3]],
					[leftMargin-steps[4], rightMargin+steps[4]],
					[leftMargin, leftMargin]
				];

			// Queue animations
			$.each(effectMargins, function(i)
			{
				var options = {
					duration: (i === 0) ? 40 : 80
				};

				// For last step
				if (i === 5)
				{
					options.complete = function()
					{
						// Reset margins
						$(this).css({
							marginLeft: '',
							marginRight: ''
						});

						// Callback
						if (callback)
						{
							callback.apply(this);
						}
					};
				}

				// Queue animation
				element.animate({ marginLeft: this[0]+'px', marginRight: this[1]+'px' }, options);
			});
		});

		return this;
	};

	/********************************************************/
	/*          16. Mobile browser chrome hidding           */
	/********************************************************/

	/*
	 * Normalized hide address bar for iOS & Android
	 * Inspired from Scott Jehl's post: http://24ways.org/2011/raising-the-bar-on-mobile
	 */

	// If there's a hash, stop here
	if (!location.hash)
	{
		// Scroll to 1
		window.scrollTo(0, 1);
		var scrollTop = 1,
			getScrollTop = function()
			{
				return window.pageYOffset || document.compatMode === 'CSS1Compat' && document.documentElement.scrollTop || document.body.scrollTop || 0;
			},

			// Reset to 0 on bodyready, if needed
			bodycheck = setInterval(function()
			{
				if (document.body)
				{
					clearInterval(bodycheck);
					scrollTop = getScrollTop();
					window.scrollTo(0, scrollTop === 1 ? 0 : 1);
				}
			}, 15);

		win.on('load', function()
		{
			setTimeout(function()
			{
				// At load, if user hasn't scrolled more than 20 or so...
				if (getScrollTop() < 20)
				{
					// Reset to hide addr bar at onload
					window.scrollTo(0, scrollTop === 1 ? 0 : 1);
				}
			}, 0);
		});
	}

	/********************************************************/
	/*                   17. Dependencies                   */
	/********************************************************/

	/*
	 * Add some easing functions if jQuery UI is not included
	 */
	if ($.easing.easeOutQuad === undefined)
	{
		$.easing.jswing = $.easing.swing;
		$.extend($.easing,
		{
			def: 'easeOutQuad',
			swing: function (x, t, b, c, d) {
				return $.easing[$.easing.def](x, t, b, c, d);
			},
			easeInQuad: function (x, t, b, c, d) {
				return c*(t/=d)*t + b;
			},
			easeOutQuad: function (x, t, b, c, d) {
				return -c *(t/=d)*(t-2) + b;
			},
			easeInOutQuad: function (x, t, b, c, d) {
				if ((t/=d/2) < 1) { return c/2*t*t + b; }
				return -c/2 * ((--t)*(t-2) - 1) + b;
			}
		});
	}

	/*
	 * Support for mousewheel event
	 * Copyright (c) 2010 Brandon Aaron (http://brandonaaron.net)
	 * Licensed under the MIT License (LICENSE.txt).
	 *
	 * Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.
	 * Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.
	 * Thanks to: Seamus Leahy for adding deltaX and deltaY
	 *
	 * Version: 3.0.4
	 *
	 * Requires: 1.2.2+
	 */

	// List of event names accross browsers
	var types = ['DOMMouseScroll', 'mousewheel'];

	// Event handler function
	function mouseWheelHandler(event)
	{
		var sentEvent = event || window.event,
			orgEvent = sentEvent.originalEvent || sentEvent,
			args = [].slice.call( arguments, 1 ),
			delta = 0,
			deltaX = 0,
			deltaY = 0;
			event = $.event.fix(orgEvent);
			event.type = "mousewheel";

		// Old school scrollwheel delta
		if ( orgEvent.wheelDelta ) { delta = orgEvent.wheelDelta/120; }
		if ( orgEvent.detail     ) { delta = -orgEvent.detail/3; }

		// New school multidimensional scroll (touchpads) deltas
		deltaY = delta;

		// Gecko
		if ( orgEvent.axis !== undefined && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
			deltaY = 0;
			deltaX = -1*delta;
		}

		// Webkit
		if ( orgEvent.wheelDeltaY !== undefined ) { deltaY = orgEvent.wheelDeltaY/120; }
		if ( orgEvent.wheelDeltaX !== undefined ) { deltaX = -1*orgEvent.wheelDeltaX/120; }

		// Add event and delta to the front of the arguments
		args.unshift(event, delta, deltaX, deltaY);

		return ($.event.dispatch || $.event.handle).apply(this, args);
	}

	// Register event
	$.event.special.mousewheel = {
		setup: function()
		{
			if (this.addEventListener)
			{
				for (var i=types.length; i;)
				{
					this.addEventListener(types[--i], mouseWheelHandler, false);
				}
			}
			else
			{
				this.onmousewheel = mouseWheelHandler;
			}
		},

		teardown: function()
		{
			if (this.removeEventListener)
			{
				for (var i=types.length; i;)
				{
					this.removeEventListener(types[--i], mouseWheelHandler, false);
				}
			}
			else
			{
				this.onmousewheel = null;
			}
		}
	};

	// Add methods
	$.fn.extend({
		mousewheel: function(fn)
		{
			return fn ? this.on("mousewheel", fn) : this.trigger("mousewheel");
		},

		unmousewheel: function(fn)
		{
			return this.off("mousewheel", fn);
		}
	});

})(this.jQuery, window, document);
 /**
 *     ___ _    __   ____            _
 *    /   | |  / /  / __ \___  _____(_)____ ____ 
 *   / /| | | / /  / / / / _ \/ ___/ / __ `/ __ \
 *  / ___ | |/ /  / /_/ /  __(__  ) / /_/ / / / /
 * /_/  |_|___/  /_____/\___/____/_/\__, /_/ /_/ 
 *                                 /____/        
 * ------------ By Anselmo Velame --------------- 
 *
 * funtions global do sistema
 * Boas prticas estruturais dos padres essenciais para usar os plugins 
 */

/*
 * The semi-colon before the function invocation is a safety
 * net against concatenated scripts and/or other plugins
 * that are not closed properly.
 */
;(function($, window, document, undefined)
{
	/*
	 * undefined is used here as the undefined global variable in ECMAScript 3 is mutable (i.e. it can
	 * be changed by someone else). undefined isn't really being passed in so we can ensure that its value is
	 * truly undefined. In ES5, undefined can no longer be modified.
	 */

	/*
	 * window and document are passed through as local variables rather than as globals, because this (slightly)
	 * quickens the resolution process and can be more efficiently minified.
	 */

	// Objects cache
	var win = $(window),
		doc = $(document);

	/**
	 * Convert switches, checkboxes and radios
	 * @param object options an object with any of the $.fn.styleCheckable.defaults options.
	 */
	$.fn.styleCheckable = function(options)
	{
		// Settings
		var globalSettings = $.extend({}, $.fn.styleCheckable.defaults, options);

		return this.each(function(i)
		{
			var element = $(this),
				settings = $.extend({}, globalSettings, element.data('checkable-options')),
				checked = this.checked ? ' checked' : '',
				disabled = this.disabled ? ' disabled' : '',
				replacement = element.data('replacement'),
				title = (this.title && this.title.length > 0) ? ' title="'+this.title+'"' : '',
				tabIndex = (this.tabIndex > 0) ? this.tabIndex : 0,
				isWatching;

			// If already set
			if (replacement)
			{
				return;
			}

			// Stop DOM watching
			isWatching = $.template.disableDOMWatch();

			// Create replacement
			if (element.hasClass('switch'))
			{
				replacement = $('<span class="'+this.className.replace(/validate\[.*\]/, '')+checked+disabled+' replacement"'+title+' tabindex="'+tabIndex+'">'+
									'<span class="switch-on"><span>'+(element.data('text-on') || settings.textOn)+'</span></span>'+
									'<span class="switch-off"><span>'+(element.data('text-off') || settings.textOff)+'</span></span>'+
									'<span class="switch-button"></span>'+
								'</span>');
			}
			else
			{
				replacement = $('<span class="'+this.className.replace(/validate\[.*\]/, '')+checked+disabled+' replacement"'+title+' tabindex="'+tabIndex+'">'+
									'<span class="check-knob"></span>'+
								'</span>');
			}

			// Prevent the element from being focusable by keyboard
			this.tabIndex = -1;

			// Insert
			replacement.insertAfter(element).data('replaced', element);

			// Store reference
			element.data('replacement', replacement);

			// Add clear function
			element.addClearFunction(_removeCheckableReplacement);

			// Move select inside replacement, and remove styling
			element.detach().appendTo(replacement).data('initial-classes', this.className);
			this.className = (this.className.indexOf('validate[') > -1) ? this.className.match(/validate\[.*\]/)[0] : '';

			// Re-enable DOM watching if required
			if (isWatching)
			{
				$.template.enableDOMWatch();
			}
		});
	};

	/*
	 * Options for styled switches, checkboxes and radios
	 */
	$.fn.styleCheckable.defaults = {
		/**
		 * Default text for ON value
		 * @var string
		 */
		textOn: 'ON',

		/**
		 * Default text for OFF value
		 * @var string
		 */
		textOff: 'OFF'
	};

	/**
	 * Convert selects
	 * @param object options an object with any of the $.fn.styleSelect.defaults options.
	 */
	$.fn.styleSelect = function(options)
	{
		// Settings
		var globalSettings = $.extend({}, $.fn.styleSelect.defaults, options);

		return this.each(function(i)
		{
			var element = $(this),
				settings = $.extend({}, globalSettings, element.data('select-options')),
				replacement = element.data('replacement'),
				disabled = this.disabled ? ' disabled' : '',
				showAsMultiple = ((this.multiple || element.hasClass('multiple')) && !element.hasClass('multiple-as-single')),
				isSized = (element.attr('size') > 1),
				title = (this.title && this.title.length > 0) ? ' title="'+this.title+'"' : '',
				tabIndex = (this.tabIndex > 0) ? this.tabIndex : 0,
				useStyledList = false,
				select, dropDown, text, isWatching, values;

			// If already set
			if (replacement)
			{
				return;
			}

			// Stop DOM watching
			isWatching = $.template.disableDOMWatch();

			/*
			 * To avoid triggering the default select UI, the select is hidden if:
			 * - it is displayed as multiple (even if simple) OR
			 * - it is multiple (no overlaying UI in most OS) OR
			 * - The setting styledList is on AND
			 *      - This is not a touch device OR
			 *      - This is a touch device AND the setting styledOnTouch is:
			 *          - true OR
			 *          - null and the select has the class 'check-list'
			 *
			 * Ew. Now I need to get another brain.
			 */
			if (showAsMultiple ||
				this.multiple ||
				(settings.styledList &&
					(!$.template.touchOs ||
					($.template.touchOs &&
						(settings.styledOnTouch === true ||
						(settings.styledOnTouch === null && element.hasClass('check-list')))))))
			{
				useStyledList = true;
			}

			// Create replacement
			if (showAsMultiple)
			{
				// Create
				select = $('<span class="'+this.className.replace(/validate\[.*\]/, '').replace(/(\s*)select(\s*)/, '$1selectMultiple$2')+disabled+' replacement"'+title+' tabindex="'+tabIndex+'">'+
								'<span class="drop-down"></span>'+
							'</span>')
				.insertAfter(element)
				.data('replaced', element);

				// Register
				element.data('replacement', select);

				// If the number of visible options is set
				if (isSized && !element.getStyleString().match(/height\s*:\s*[0-9]+/i))
				{
					// Set height
					dropDown = select.children('.drop-down');
					dropDown.height(element.hasClass('check-list') ? (this.size*37)-1 : this.size*26);

					// Enable scroll
					if ($.fn.customScroll)
					{
						dropDown.customScroll({
							padding: 4,
							showOnHover: false,
							usePadding: true,
							verticalOnLeft: element.hasClass('reversed-scroll')
						});
					}
				}

				// Load options
				_refreshSelectValues(select, element);

				// Custom event to refresh values list
				element.on('change silent-change update-select-list', function(event)
				{
					_refreshSelectValues(select, element);
				});
			}
			else
			{
				// Create
				select = $('<span class="'+this.className.replace(/validate\[.*\]/, '')+disabled+' replacement"'+title+' tabindex="'+tabIndex+'">'+
								'<span class="select-value"></span>'+
								'<span class="select-arrow">'+($.template.ie7 ? '<span class="select-arrow-before"></span><span class="select-arrow-after"></span>' : '')+'</span>'+
								( useStyledList ? '<span class="drop-down"></span>' : '' )+
							'</span>')
				.insertAfter(element)
				.data('replaced', element);

				// Gather selected values texts
				values = [];
				element.find(':selected').each(function(i)
				{
					values.push($(this).text());
				});

				// Update displayed value
				if (settings.staticValue)
				{
					select.children('.select-value').html(settings.staticValue);
				}
				else if (this.multiple)
				{
					switch (values.length)
					{
						case 0:
							_updateSelectValueText(select.children('.select-value'), values, element.data('no-value-text'), settings.noValueText);
							break;

						case 1:
							_updateSelectValueText(select.children('.select-value'), values, element.data('single-value-text'), settings.singleValueText);
							break;

						case this.options.length:
							_updateSelectValueText(select.children('.select-value'), values, element.data('all-values-text'), settings.allValuesText);
							break;

						default:
							_updateSelectValueText(select.children('.select-value'), values, element.data('multiple-values-text'), settings.multipleValuesText);
							break;
					}
				}
				else
				{
					select.children('.select-value').html((values.length > 0) ? values.pop() : '&nbsp;');
				}

				// Register
				element.data('replacement', select);

				// Refresh size mode
				_refreshSelectSize(select, this, select.children('.drop-down'));
			}

			// Prevent the element from being focusable by keyboard
			this.tabIndex = -1;

			// Move select inside replacement, and remove styling
			element.detach().prependTo(select).data('initial-classes', this.className);
			this.className = (this.className.indexOf('validate[') > -1) ? this.className.match(/validate\[.*\]/)[0] : '';

			// Add clear function
			element.addClearFunction(_removeSelectReplacement);

			// Store settings
			select.data('select-settings', settings);

			// Styling for elements with active list styling
			if (useStyledList)
			{
				select.addClass('select-styled-list');
			}

			// Re-enable DOM watching if required
			if (isWatching)
			{
				$.template.enableDOMWatch();
			}
		});
	};

	/*
	 * Options for styled selects
	 */
	$.fn.styleSelect.defaults = {
		/**
		 * False to use system's drop-down UI, true to use style's drop-downs
		 * @var boolean
		 */
		styledList: true,

		/**
		 * For touch devices: false to use system's drop-down UI, true to use style's drop-downs, or null to guess (true for check-list style, false for others)
		 * Note: only works if styledList is true
		 * @var boolean|null
		 */
		styledOnTouch: null,

		/**
		 * When focused, should the arrow down key open the drop-down or just scroll values?
		 * @var boolean
		 */
		openOnKeyDown: true,

		/**
		 * Text for multiple select with no value selected
		 * @var string
		 */
		noValueText: '',

		/**
		 * Static text, always displayed no matter the value
		 * @var string|boolean
		 */
		staticValue: false,

		/**
		 * Text for multiple select with one value selected, or false to just display the selected value
		 * @var string|boolean
		 */
		singleValueText: false,

		/**
		 * Text for multiple select with multiple values selected, or false to just display the selected list
		 * Tip: use %d as a placeholder for the number of values
		 * @var string|boolean
		 */
		multipleValuesText: '%d selected',

		/**
		 * Text for multiple select with all values selected, or false to just display the selected list
		 * Tip: use %d as a placeholder for the number of values
		 * @var string|boolean
		 */
		allValuesText: 'All',

		/**
		 * Enable search field when open - use null to automatically use when list has more than searchIfMoreThan elements
		 * @var boolean|null
		 */
		searchField: null,

		/**
		 * Minimum number of elements to trigger a search field, if searchField is null
		 * @var int
		 */
		searchIfMoreThan: 25,

		/**
		 * Helper text for seach field
		 * @var string
		 */
		searchText: 'Search'
	};

	/**
	 * Convert file inputs
	 * @param object options an object with any of the $.fn.styleFile.defaults options.
	 */
	$.fn.styleFile = function(options)
	{
		// Settings
		var globalSettings = $.extend({}, $.fn.styleFile.defaults, options);

		return this.each(function(i)
		{
			var element = $(this).addClass('file'),
				settings = $.extend({}, globalSettings, element.data('file-options')),
				blackInput = (element.hasClass('black-input') || element.closest('.black-inputs').length > 0) ? ' anthracite-gradient' : '',
				multiple = !!this.multiple,
				disabled = this.disabled ? ' disabled' : '',
				isWatching;

			// If already set
			if (element.parent().hasClass('file'))
			{
				return;
			}

			// Stop DOM watching
			isWatching = $.template.disableDOMWatch();

			// Create styling
			styling = $('<span class="input '+this.className.replace(/validate\[.*\]/, '')+disabled+'">'+
							'<span class="file-text">'+element.val()+'</span>'+
							'<span class="button compact'+blackInput+'">'+(multiple ? settings.textMultiple : settings.textSingle)+'</span>'+
						'</span>');

			// Insert
			styling.insertAfter(element);

			// Add clear function
			element.addClearFunction(_removeInputStyling);

			// Move select inside styling
			element.detach().appendTo(styling);

			// Re-enable DOM watching if required
			if (isWatching)
			{
				$.template.enableDOMWatch();
			}
		});
	};

	/*
	 * Options for styled switches, checkboxes and radios
	 */
	$.fn.styleFile.defaults = {
		/**
		 * Button text - single file
		 * @var string
		 */
		textSingle: 'Selecione',

		/**
		 * Button text - multiple files
		 * @var string
		 */
		textMultiple: 'Selecione'
	};

	/**
	 * Set the value of a number input
	 * @param number value the value to set
	 */
	$.fn.setNumber = function(value)
	{
		return this.each(function(i)
		{
			var input;

			// Detect input
			if (this.nodeName.toLowerCase() === 'input')
			{
				input = $(this);
			}
			else
			{
				input = $(this).children('input:first');
				if (input.length === 0)
				{
					return;
				}
			}

			// Set value
			input.val(_formatNumberValue(value, _getNumberOptions(input)));
		});
	};

	/**
	 * Increment/decrement the value of a number input
	 * @param boolean up true if the value should be incremented, false for decremented
	 * @param boolean shift whether to use shiftIncrement or not (optional, default: false)
	 */
	$.fn.incrementNumber = function(up, shift)
	{
		return this.each(function(i)
		{
			var input, options, value;

			// Detect input
			if (this.nodeName.toLowerCase() === 'input')
			{
				input = $(this);
			}
			else
			{
				input = $(this).children('input:first');
				if (input.length === 0)
				{
					return;
				}
			}

			// Options
			options = _getNumberOptions(input);

			// Remove format
			value = _unformatNumberValue(input.val(), options);

			// Check if numeric
			if (isNaN(value))
			{
				value = 0;
			}

			// Increment value
			value += up ? (shift ? options.shiftIncrement : options.increment) : (shift ? -options.shiftIncrement : -options.increment);

			// Set value
			input.val(_formatNumberValue(value, options));
		});
	};

	/**
	 * Helper function: load and format number input options
	 * @param jQuery input the target input
	 * @return object the options object
	 */
	function _getNumberOptions(input)
	{
		var options = input.data('number-options'),
			temp;

		// If not set yet or not formatted
		if (!options || !options.formatted)
		{
			// Extend
			options = $.extend({}, $.fn.setNumber.defaults, options);

			// Validate
			if (typeof options.min !== 'number')
			{
				options.min = null;
			}
			if (typeof options.max !== 'number')
			{
				options.max = null;
			}
			if (options.min !== null && options.max !== null)
			{
				if (options.min > options.max)
				{
					temp = options.max;
					options.max = options.min;
					options.min = temp;
				}
			}
			if (!options.precision)
			{
				options.precision = 1;
			}

			// Set as ready
			options.formatted = true;
			input.data('number-options', options);
		}

		return options;
	}

	/**
	 * Helper function: remove user format of a number value according to options
	 * @param value the value
	 * @param object options the validated options
	 * @return number the valid value
	 */
	function _unformatNumberValue(value, options)
	{
		if (typeof value === 'string')
		{
			if (options.thousandsSep.length)
			{
				value = value.replace(options.thousandsSep, '');
			}
			if (options.decimalPoint !== '.')
			{
				value = value.replace(options.decimalPoint, '.');
			}
			value = parseFloat(value);
			if (isNaN(value))
			{
				value = 0;
			}
		}

		return value;
	}

	/**
	 * Helper function: format a number value according to options
	 * @param value the value
	 * @param object options the validated options
	 * @return number|string the valid value
	 */
	function _formatNumberValue(value, options)
	{
		var parts, decimalPlaces;

		// Remove format
		value = _unformatNumberValue(value, options);

		// Round value
		value = Math.round(value/options.precision)*options.precision;

		// Precision bug on float values
		if (options.precision < 1)
		{
			decimalPlaces = options.precision.toString().length-2;
			value = Math.round(value*Math.pow(10, decimalPlaces))/Math.pow(10, decimalPlaces);
		}

		// Check min/max
		if (options.min !== null)
		{
			value = Math.max(value, options.min);
		}
		if (options.max !== null)
		{
			value = Math.min(value, options.max);
		}

		// If not standard
		if (options.thousandsSep.length || options.decimalPoint !== '.')
		{
			// Format value
			parts = value.toString().split('.');

			// Thousands separator
			if (options.thousandsSep.length && parts[0].length > 3)
			{
				parts[0] = parts[0].replace(/\B(?=(?:\d{3})+(?!\d))/g, options.thousandsSep);
			}

			return parts.join(options.decimalPoint);
		}

		return value;
	}

	/*
	 * Options for number inputs
	 */
	$.fn.setNumber.defaults = {
		/**
		 * Minimum value (null for none)
		 * @var number|null
		 */
		min: null,

		/**
		 * Maximum value (null for none)
		 * @var number|null
		 */
		max: null,

		/**
		 * Increment of up/down arrows and keys
		 * @var number
		 */
		increment: 1,

		/**
		 * Increment of up/down arrows and keys when holding shift key
		 * @var number
		 */
		shiftIncrement: 10,

		/**
		 * Precision of the value: the user input will be rounded using it.
		 * For instance, use 1 for rounded nombers, 0.25 to user quarter increments...
		 * @var number
		 */
		precision: 1,

		/**
		 * Character used for decimal point
		 * @var string
		 */
		decimalPoint: '.',

		/**
		 * Character used for thousands separator
		 * @var string
		 */
		thousandsSep: ''
	};

	/**
	 * Helper function to check if an element is an input/select/textarea/button and may be disabled
	 * @param jQuery element the element to check
	 * @return boolean true if the element may be disabled, else false
	 */
	function mayBeDisabled(element)
	{
		var nodeName = element[0].nodeName.toLowerCase();
		return (nodeName === 'input' || nodeName === 'select' || nodeName === 'textarea' || nodeName === 'button');
	}

	/**
	 * Enable a form input, and update the styled UI
	 */
	$.fn.enableInput = function()
	{
		return this.each(function(i)
		{
			var element = $(this),
				replacement, replaced;

			// Inputs
			if (mayBeDisabled(element))
			{
				// Enable
				element.prop('disabled', false);

				// Style
				replacement = element.data('replacement');
				if (replacement)
				{
					replacement.removeClass('disabled');
				}

				// Number inputs
				if (element.parent().hasClass('number'))
				{
					element.parent().removeClass('disabled');
				}
			}
			// Replacements
			else
			{
				// Look for input
				replaced = element.data('replaced');
				if (replaced && mayBeDisabled(replaced))
				{
					// Enable input
					replaced.prop('disabled', false);

					// Style
					element.removeClass('disabled');
				}
				// Number inputs
				else if (element.hasClass('number'))
				{
					element.removeClass('disabled');
					element.children('input').prop('disabled', false);
				}
			}
		});
	};

	/**
	 * Disable a form input, and update the styled UI
	 */
	$.fn.disableInput = function()
	{
		return this.each(function(i)
		{
			var element = $(this),
				replacement, replaced;

			// Inputs
			if (mayBeDisabled(element))
			{
				// Disable
				element.prop('disabled', true);

				// Style
				replacement = element.data('replacement');
				if (replacement)
				{
					replacement.addClass('disabled');
				}

				// Number inputs
				if (element.parent().hasClass('number'))
				{
					element.parent().addClass('disabled');
				}
			}
			// Replacements
			else
			{
				// Look for input
				replaced = element.data('replaced');
				if (replaced && mayBeDisabled(replaced))
				{
					// Disable input
					replaced.prop('disabled', true);

					// Style
					element.addClass('disabled');
				}
				// Number inputs
				else if (element.hasClass('number'))
				{
					element.addClass('disabled');
					element.children('input').prop('disabled', true);
				}
			}
		});
	};

	// Add to template setup function
	$.template.addSetupFunction(function(self, children)
	{
		var elements = this;

		// Switches, checkboxes and radios
		elements.findIn(self, children, 'input.switch, input.checkbox, input.radio').each(function(i)
		{
			// Style element
			$(this).styleCheckable();

			// If in the root target, add to selection
			if (self && elements.is(this))
			{
				elements = elements.add(this);
			}
		});

		// Checkables in buttons
		elements.findIn(self, children, 'label.button').children(':radio, :checkbox').each(function(i)
		{
			// Style element
			if (this.checked)
			{
				$(this).parent().addClass('active');
			}
		});

		// File inputs
		elements.findIn(self, children, '.file').filter('input[type="file"]').styleFile();

		// Placeholder polyfill
		if (!Modernizr.input.placeholder)
		{
			elements.findIn(self, children, 'input[placeholder][type!="password"]').each(function(i)
			{
				var input = $(this),
					placeholder = input.attr('placeholder');

				// Mark and add data for validation plugin
				input.addClass('placeholder').attr('data-validation-placeholder', placeholder);

				// Fill if empty
				if ($.trim(input.val()) === '')
				{
					input.val(placeholder);
				}
			});
		}

		// Selects
		elements.findIn(self, children, 'select.select').each(function(i)
		{
			// Style element
			$(this).styleSelect();

			// If in the root target, add to selection
			if (self && elements.is(this))
			{
				elements = elements.add(this);
			}
		});

		return elements;
	});

	/********************************************************/
	/*                   Helper functions                   */
	/********************************************************/

	/**
	 * Open a select drop-down list
	 *
	 * @param jQuery select the replacement select
	 * @param boolean onHover whether the select was open on hover or not (optional, default: none)
	 * @param event the opening event (optional)
	 * @return void
	 */
	function _openSelect(select, onHover, event)
	{
		var replaced = select.data('replaced'),
			settings = select.data('select-settings') || {},
			list,
			clone,
			inheritParent,
			scrollParents,
			position, listOffset,
			winHeight, listHeight, optionHeight,
			listExtra, availableHeight,
			searchWrapper, search = false, searchFocus = false,
			date = new Date(), time = date.getTime(),
			isWatching, updateList, onChange, onBlur;

		// Prevent event default
		if (event)
		{
			event.preventDefault();
		}

		// Do not handle if disabled
		if (select.closest('.disabled').length > 0 || (replaced && replaced.is(':disabled')))
		{
			return;
		}

		// Do not handle if the OS UI should be used
		if (replaced && !select.hasClass('select-styled-list'))
		{
			return;
		}

		// If already open
		if (select.hasClass('select-cloned'))
		{
			return;
		}

		// List of scrolling parents
		scrollParents = select.parents('.custom-scroll');

		// Add class if the select is in a top-level element
		if (select.closest('.modal, .notification, .tooltip').length)
		{
			select.addClass('over');
		}
		else
		{
			select.removeClass('over');
		}

		// Stop DOM watching
		isWatching = $.template.disableDOMWatch();

		// Clone
		clone = select.clone().addClass('select-clone').css('width', select.width()+'px');
		clone[0].tabIndex = -1;
		clone.children('select').remove();
		clone.appendTo(document.body).trackElement(select);

		// Some browsers report wrong values for the first call to determine the select position - hope to fix that soon...
		setTimeout(function()
		{
			select.refreshTrackedElements();
		}, 1);

		// Store reference
		select.data('clone', clone);

		// Hide - need to add an internal marker as it makes the select lose focus in some browsers */
		select.data('select-hiding', true).addClass('select-cloned');
		setTimeout(function()
		{
			select.removeData('select-hiding');
		}, 100);

		// Refernce
		list = clone.children('.drop-down');

		// Fill options list
		if (replaced)
		{
			clone.data('replaced', replaced);
			_refreshSelectValues(clone, replaced);

			// Listen for changes
			onChange = function(event)
			{
				// Refresh list
				_refreshSelectValues(clone, replaced);

				// Update displayed value
				_updateSelectText(clone, replaced, select.data('select-settings'));
			};
			replaced.on('change silent-change update-select-list', onChange);
		}

		/*
		 * Inherited classes checks
		 */

		// Glossy
		if (!select.is('.glossy'))
		{
			inheritParent = select.closest('.glossy');
			if (inheritParent.length > 0)
			{
				clone.addClass('glossy');
			}
		}

		// Size
		if (!select.is('.compact'))
		{
			inheritParent = select.parent('.compact');
			if (inheritParent.length > 0)
			{
				clone.addClass('compact');
			}
		}

		// Re-enable DOM watching if required
		if (isWatching)
		{
			$.template.enableDOMWatch();
		}

		// Prepare and open
		clone.removeClass('reversed').addClass('open');
		if (replaced)
		{
			list.on('touchend click', function(event)
			{
				// Check if scrolling
				if (event.type === 'touchend' && list.data('touch-scrolling'))
				{
					return;
				}
				event.stopPropagation();
			});
		}

		/*
		 * Search field
		 */

		// If search field should be used
		if (!clone.hasClass('auto-open') && (settings.searchField === true || (settings.searchField === null && list.children('a, span').length >= settings.searchIfMoreThan)))
		{
			// Create elements
			searchWrapper = $('<div class="select-search-wrapper"></div>').appendTo(clone);
			search = $('<input type="text" class="select-search" value="" placeholder="'+settings.searchText+'" autocomplete="off">').appendTo(searchWrapper);

			// Behavior
			search.on('keydown', function(event)
			{
				event.stopPropagation();

			}).on('focus', function(event)
			{
				searchFocus = true;

			}).on('blur', function(event)
			{
				searchFocus = false;

			}).keyup(function(event)
			{
				var text = $.trim(search.val()),
					keys = $.template.keys,
					searchRegex,
					matches, matchSelected,
					focus, next,
					replacedOption;

				event.stopPropagation();

				// Key handling
				switch (event.keyCode)
				{
					case keys.up:
						// Focused element
						matches = list.children('a, span').not('.disabled').not(':hidden');
						focus = matches.filter('.selected:first');
						if (focus.length === 0)
						{
							next = matches.last();
						}
						else
						{
							next = focus.prevAll('a, span').not('.disabled').not(':hidden').first();
						}

						// Focus previous option
						if (next.length > 0)
						{
							focus.removeClass('selected');
							next.addClass('selected');
							if ($.fn.scrollToReveal)
							{
								next.scrollToReveal();
							}

							// Update replaced and trigger change
							if (replaced)
							{
								replacedOption = next.data('select-value');
								if (replacedOption)
								{
									// If multiple selection, clear all before
									if (replaced[0].multiple)
									{
										replaced.find('option:selected').prop('selected', false);
									}

									replacedOption.selected = true;
									replaced.trigger('change');
								}
							}
						}
						break;

					case keys.down:
						// Focused element
						matches = list.children('a, span').not('.disabled').not(':hidden');
						focus = matches.filter('.selected:last');
						if (focus.length === 0)
						{
							next = matches.first();
						}
						else
						{
							next = focus.nextAll('a, span').not('.disabled').not(':hidden').first();
						}

						// Focus next option
						if (next.length > 0)
						{
							focus.removeClass('selected');
							next.addClass('selected');
							if ($.fn.scrollToReveal)
							{
								next.scrollToReveal();
							}

							// Update replaced and trigger change
							if (replaced)
							{
								replacedOption = next.data('select-value');
								if (replacedOption)
								{
									// If multiple selection, clear all before
									if (replaced[0].multiple)
									{
										replaced.find('option:selected').prop('selected', false);
									}

									replacedOption.selected = true;
									replaced.trigger('change');
								}
							}
						}
						break;

					case keys.enter:
					case keys.space:
						// Just close the select if open
						select.trigger('close-select');
						break;

					default:
						// If search is empty
						if (text.length === 0)
						{
							list.children('a, span').show();
						}
						else
						{
							// Regular expression
							searchRegex = new RegExp(text.toLowerCase(), 'g');

							// Loop through values to find a match
							list.children('a, span').each(function(i)
							{
								var option = $(this);

								// If matches
								if ($.trim(option.text().toLowerCase()).match(searchRegex))
								{
									option.show();
								}
								else
								{
									option.hide();
								}
							});
						}
						break;
				}
			});
		}

		/*
		 * Set select list position according to available screen space
		 */

		// Add scroll
		if ($.fn.customScroll && !list.hasCustomScroll())
		{
			list.customScroll({
				padding: 4,
				showOnHover: false,
				usePadding: true,
				continuousWheelScroll: false,
				continuousTouchScroll: false,
				verticalOnLeft: select.hasClass('reversed-scroll')
			});
		}

		// Get heights
		listOffset = list.removeClass('reversed').position().top;
		listHeight = list.outerHeight();
		listExtra = listHeight-list.height();

		// Function to refresh position on resize/scroll
		updateList = function()
		{
			var scrollPos;

			// Refresh size
			listHeight = list.css('max-height', '').outerHeight();

			// Select vertical position
			position = clone.offset().top-win.scrollTop();

			// Viewport height
			winHeight = win.height();

			// If too long to fit
			if (position+listOffset+listHeight > winHeight)
			{
				// Check if it fits on top
				if (position-listOffset-listHeight > 0)
				{
					// Display on top
					clone.addClass('reversed');
				}
				/*
				 * Now we know that the list can't be displayed full size, so we truncate it.
				 * If the select is above 60% of screen height, it will show under, otherwise on top
				 */
				else
				{
					if (position > winHeight*0.6)
					{
						// Display on top
						clone.addClass('reversed');
						availableHeight = position;
					}
					else
					{
						// Display under
						clone.removeClass('reversed');
						availableHeight = winHeight-position-listOffset;
					}

					// Remove list padding/borders from available size
					availableHeight -= listExtra;

					// Set max-height to use available space
					list.css({
						maxHeight: (availableHeight-10)+'px'
					});

					// Try to restore scroll position
					scrollPos = select.data('scrollPosition');
					if (scrollPos)
					{
						list[0].scrollTop = scrollPos;
					}
				}
			}
			else
			{
				// Clear changes
				clone.removeClass('reversed');
			}

			// Clear data
			select.removeData('scrollPosition');

			// Update scroll
			if ($.fn.customScroll)
			{
				list.refreshCustomScroll();
			}
		};

		// Function to handle focus loss
		onBlur = function(event)
		{
			var target = $(event.target);

			// Validation for click/touchend event
			if ((event.type === 'click' || event.type === 'touchend') && (target.closest(list).length || (searchWrapper && target.closest(searchWrapper).length)))
			{
				return;
			}
			// Validation for scroll events when search field has focus
			else if (event.type === 'scroll' && searchFocus)
			{
				updateList();
				return;
			}

			// Remove events
			win.off('resize', updateList);
			doc.off('scroll', onBlur);
			scrollParents.off('scroll', onBlur);
			if (onHover && !$.template.touchOs)
			{
				clone.off('mouseleave', onBlur);
			}
			else
			{
				doc.off('touchend click', onBlur);
			}
			select.off('close-select', onBlur);
			clone.off('close-select', onBlur);

			// Stop listening for changes
			if (replaced)
			{
				replaced.off('change silent-change update-select-list', onChange);
			}

			// Remove search field
			if (search)
			{
				list.children('a, span').show();
			}

			// Store scroll position for later re-opening
			select.data('scrollPosition', list[0].scrollTop);

			// Stop DOM watching
			isWatching = $.template.disableDOMWatch();

			// Put element back in place
			clone.detach();		// Detach is used to preserve event listeners
			select.removeData('clone').removeClass('select-cloned');

			// Re-enable DOM watching if required
			if (isWatching)
			{
				$.template.enableDOMWatch();
			}
		};

		// First call and binding
		updateList();
		win.on('resize', updateList);
		doc.on('scroll', onBlur);
		scrollParents.on('scroll', onBlur);
		if (onHover && !$.template.touchOs)
		{
			clone.on('mouseleave', onBlur);
		}
		else
		{
			doc.on('touchend click', onBlur);
		}
		clone.on('close-select', onBlur);
		select.on('close-select', onBlur);
	}

	/**
	 * Detect fixed or fluid size
	 *
	 * @param jQuery select the replacement select
	 * @param DOM replaced the replaced select
	 * @param jQuery list the replacement drop-down list
	 * @return void
	 */
	function _refreshSelectSize(select, replaced, list)
	{
		// Detect fixed width
		if (replaced.style.width !== '' && replaced.style.width != 'auto')
		{
			if (!select.hasClass('fixedWidth'))
			{
				select.addClass('fixedWidth');
				if (select.hasClass('selectMultiple'))
				{
					list.css('width', replaced.style.width);
				}
			}
		}
		else
		{
			if (select.hasClass('fixedWidth'))
			{
				select.removeClass('fixedWidth');
				if (select.hasClass('selectMultiple'))
				{
					list.css('width', '');
				}
			}
		}
	}

	/**
	 * Refresh select values
	 *
	 * @param jQuery select the replacement select
	 * @param jQuery replaced the replaced select
	 * @return void
	 */
	function _refreshSelectValues(select, replaced)
	{
		var list = select.children('.drop-down'),
			checkList = select.hasClass('check-list') ? '<span class="check"></span>' : '',
			existing, isWatching;

		// If valid
		if (list.length > 0 && replaced)
		{
			// Disable DOM watching for better performance
			isWatching = $.template.disableDOMWatch();

			// Refresh size mode
			_refreshSelectSize(select, replaced[0], list);

			// Existing options
			existing = list.children('span, strong');

			// Synchronise list
			replaced.find('option, optgroup').each(function(i)
			{
				var classes = [],
					$this = this,
					option = (this.nodeName.toLowerCase() === 'option'),
					node = option ? 'span' : 'strong',
					text = option ? $(this).text() : this.label,
					found = false,
					newItem;

				// Empty text
				if (text.length === 0)
				{
					if (!option)
					{
						return;
					}
					text = '&nbsp;';
				}

				// Check if the element already exists
				if (existing.length)
				{
					existing.each(function()
					{
						var element = $(this);
						if (element.data('select-value') === $this)
						{
							found = element;
							existing = existing.not(this);
							return false;
						}
					});
				}

				// If the item already exists
				if (found)
				{
					// Put at end to use right order
					found.detach().appendTo(list);

					// Reset text in case it changed
					found.html(checkList+text);

					// Check classes
					found[this.selected ? 'addClass' : 'removeClass']('selected');
					found[(this.parentNode.nodeName.toLowerCase() === 'optgroup') ? 'addClass' : 'removeClass']('in-group');
					found[this.disabled ? 'addClass' : 'removeClass']('disabled');

					// Done
					return;
				}

				// Mode
				if (option)
				{
					// State
					if (this.selected)
					{
						classes.push('selected');
					}

					// If in an optgroup
					if (this.parentNode.nodeName.toLowerCase() === 'optgroup')
					{
						classes.push('in-group');
					}

					// If disabled
					if (this.disabled)
					{
						classes.push('disabled');
					}
				}

				// Create
				newItem = $('<'+node+((classes.length > 0) ? ' class="'+classes.join(' ')+'"' : '')+'>'+checkList+text+'</'+node+'>')
							.appendTo(list)
							.data('select-value', this);

				// Set behavior if not disabled
				if (option && !this.disabled)
				{
					newItem.on('touchend click', _clickSelectValue);
				}
			});

			// Remove items not found
			if (existing.length)
			{
				existing.remove();
			}

			// Re-enable DOM watching if required
			if (isWatching)
			{
				$.template.enableDOMWatch();
			}
		}
	}

	/**
	 * Select a list value
	 *
	 * @param object event
	 * @return void
	 */
	function _clickSelectValue(event)
	{
		var option = $(this),
			list = option.parent(),
			select = list.parent(),
			replaced = select.data('replaced'),
			replacedOption = option.data('select-value'),
			multiple = replaced[0].multiple,
			selected, value;

		// Detect touch scrolling
		if (list.data('touch-scrolling'))
		{
			return;
		}

		// Check if valid touch-click event
		if (!$.template.processTouchClick(this, event))
		{
			event.stopPropagation();
			return;
		}

		// If valid
		if (replaced && replacedOption)
		{
			// If multiple selection and holding ctrl/cmd
			if (multiple && ($.template.touchOs || event.ctrlKey || event.metaKey || select.hasClass('easy-multiple-selection')))
			{
				// Current option state
				selected = option.hasClass('selected');

				// Multiple selects require a last one selected option, except if marked
				if (!select.hasClass('allow-empty'))
				{
					// Only change if the option wasn't selected, or if there is at least one other selected option
					if (!selected || (selected && (value = replaced.val()) && value.length > 1))
					{
						// Update select
						replacedOption.selected = !selected;
						replaced.trigger('change');
					}
				}
				else
				{
					// Default behavior
					replacedOption.selected = !selected;
					replaced.trigger('change');
				}
			}
			// Standard selection mode
			else
			{
				// Get current value
				value = replaced.val();
				if (multiple && (value === null || value === undefined))
				{
					value = [];
				}

				// Compare depending on mode
				if ((multiple && (value.length !== 1 || value[0] !== replacedOption.value)) || (!multiple && value !== replacedOption.value))
				{
					// Update select
					replaced.val(replacedOption.value).trigger('change');
				}

				// Close select
				if (!select.hasClass('selectMultiple'))
				{
					select.trigger('close-select');
				}
			}
		}
	}

	/**
	 * Updates the select text
	 *
	 * @param jQuery select the replacement select
	 * @param jQuery replaced the replaced select
	 * @param object settings the options (may be from another object)
	 * @return void
	 */
	function _updateSelectText(select, replaced, settings)
	{
		var selected = replaced.find(':selected'),
			selectValue = select.children('.select-value'),
			values = [],
			text;

		// Not for multiple selects
		if (select.hasClass('selectMultiple'))
		{
			return;
		}

		// Static text
		if (settings.staticValue)
		{
			selectValue.html(settings.staticValue);
			return;
		}

		// If nothing selected
		if (selected.length === 0)
		{
			// Get empty placeholder
			text = replaced.data('no-value-text') || settings.noValueText;

			// Must not be empty to preserve vertical-align
			if (!text || text.length === 0)
			{
				text = '&nbsp;';
			}

			// Set text
			selectValue.addClass('alt').html(text);
		}
		else
		{
			// Gather selected values texts
			selected.each(function(i)
			{
				values.push($(this).text());
			});

			// Update displayed value
			if (replaced[0].multiple)
			{
				switch (values.length)
				{
					case 1:
						_updateSelectValueText(selectValue, values, replaced.data('single-value-text'), settings.singleValueText);
						break;

					case replaced[0].options.length:
						_updateSelectValueText(selectValue, values, replaced.data('all-values-text'), settings.allValuesText);
						break;

					default:
						_updateSelectValueText(selectValue, values, replaced.data('multiple-values-text'), settings.multipleValuesText);
						break;
				}
			}
			else
			{
				selectValue.text((values.length > 0) ? values.join(', ') : '&nbsp;');
			}
		}
	}

	/**
	 * Set the select replacement text according to options
	 *
	 * @param jQuery selectValue the text block
	 * @param array values the list of selected values text
	 * @param string|boolean dataText template specified in the element's data, if any
	 * @param string|boolean defaultText default value
	 * @return void
	 */
	function _updateSelectValueText(selectValue, values, dataText, defaultText)
	{
		// If no user value, use default
		if (!dataText)
		{
			dataText = defaultText;
		}

		// Must not be empty to preserve vertical-align
		if (typeof dataText === 'string' && dataText.length === 0)
		{
			dataText = '&nbsp;';
		}

		// Check format
		if (typeof dataText === 'boolean')
		{
			selectValue.removeClass('alt').html((values.length > 0) ? values.join(', ') : '&nbsp;');
		}
		else
		{
			selectValue.addClass('alt').html(dataText.replace('%d', values.length));
		}
	}

	/**
	 * Get a select selected value index
	 *
	 * @param jQuery select the select selection
	 * @return int|boolean, the selected index, or -1 if none, or false if several values are selected
	 */
	function _getSelectedIndex(select)
	{
		// Mode
		if (select[0].multiple)
		{
			// Multiple select values
			val = select.val();

			// If several values
			if (val && val.length > 1)
			{
				selectedIndex = false;
			}
			else
			{
				selectedIndex = select[0].selectedIndex;
			}
		}
		else
		{
			selectedIndex = select[0].selectedIndex;
		}

		// Detect if undefined
		if (selectedIndex === null || selectedIndex === undefined)
		{
			selectedIndex = -1;
		}

		return selectedIndex;
	}

	/**
	 * Clean delete of a radio/checkbox replacement
	 *
	 * @return void
	 */
	function _removeCheckableReplacement()
	{
		var element = $(this),
			replacement = element.data('replacement'),
			blurFunc;

		// If not replaced
		if (!replacement)
		{
			return;
		}

		// If focused
		blurFunc = replacement.data('checkableBlurFunction');
		if (blurFunc)
		{
			blurFunc();
		}

		// Tabindex
		this.tabIndex = select[0].tabIndex;

		// Remove select from replacement and restore classes
		element.detach().insertBefore(replacement).css('display', '');
		this.className = element.data('initial-classes');
		element.removeData('initial-classes');

		// Remove references
		element.removeData('replacement');

		// Delete replacement
		replacement.remove();
	}

	/**
	 * Clean delete of a select replacement
	 *
	 * @return void
	 */
	function _removeSelectReplacement()
	{
		var element = $(this),
			select = element.data('replacement');

		// If not replaced
		if (!select)
		{
			return;
		}

		// If open
		if (select.hasClass('select-cloned'))
		{
			select.trigger('close-select');
		}

		// If focused
		if (select.hasClass('focus'))
		{
			select.blur();
		}

		// Tabindex
		if (select[0].tabIndex > 0)
		{
			this.tabIndex = select[0].tabIndex;
		}

		// Remove select from replacement and restore classes
		element.detach().insertBefore(select).css('display', '');
		this.className = element.data('initial-classes');
		element.removeData('initial-classes');

		// Remove references
		element.removeData('replacement');

		// Stop scrolling
		if ($.fn.customScroll)
		{
			select.children('.drop-down').removeCustomScroll();
		}

		// Delete select
		select.remove();
	}

	/**
	 * Clean delete of a file input replacement
	 *
	 * @return void
	 */
	function _removeInputStyling()
	{
		var element = $(this),
			parent = element.parent();

		// If not replaced
		if (!parent.hasClass('file'))
		{
			return;
		}

		// Remove input from styling
		element.detach().insertBefore(parent);

		// Delete styling
		parent.remove();
	}

	/********************************************************/
	/*        Event delegation for template elements        */
	/********************************************************/

	/*
	 * Event delegation is used to handle most of the template setup, as it does also apply to dynamically added elements
	 * @see http://api.jquery.com/on/
	 */

	doc.on('click', 'label', function(event)
	{
		var label = $(this),
			element = $('#'+this.htmlFor),
			replacement;

		// If no input, exit
		if (element.length === 0)
		{
			return;
		}

		// Replacement
		replacement = element.data('replacement');

		// IE7/8 only triggers 'change' on blur and does not handle change on 'click' for hidden elements, so we need to use a workaround
		if ($.template.ie7 || $.template.ie8)
		{
			// If checkbox/radio
			if (element.is(':checkbox, :radio'))
			{
				// If replaced
				if (replacement)
				{
					// Trigger event
					replacement.trigger('click');
					return;
				}

				// If checkable is included in label
				if (label.hasClass('button') && element.closest('label').is(label))
				{
					// Do not handle if disabled
					if (element.closest('.disabled').length > 0 || element.is(':disabled'))
					{
						return;
					}

					// Check if state can be changed
					if (element.is(':checkbox') || !element.prop('checked'))
					{
						element.prop('checked', !element.prop('checked')).trigger('change');
					}
				}

				return;
			}
		}

		// If hidden select
		if (element.is('select'))
		{
			// Only process if hidden
			if (replacement && element.is(':hidden'))
			{
				replacement.focus();
			}
		}
	});

	// Change radio/checkboxes
	doc.on('click', 'span.switch, span.radio, span.checkbox', function(event)
	{
		var element = $(this),
			replaced = element.data('replaced');

		// If not valid, exit
		if (!replaced || replaced.length === 0)
		{
			return;
		}

		// Only process if not clicking in the inner checkable
		if (event.target === replaced[0])
		{
			return;
		}

		// Do not handle if disabled
		if (element.closest('.disabled').length > 0 || replaced.is(':disabled'))
		{
			return;
		}

		// If dragged too recently
		if (element.data('switch-dragged'))
		{
			return;
		}

		// Check if state can be changed
		if (replaced.is(':checkbox') || !replaced.prop('checked'))
		{
			replaced.prop('checked', !replaced.prop('checked')).trigger('change');
		}
	});

	// Drag switches
	doc.on('mousedown touchstart', 'span.switch', function(event)
	{
			// Parent switch
		var switchEl = $(this),
			replaced = switchEl.data('replaced'),
			reversed = (switchEl.closest('.reversed-switches').length > 0),

			// Button
			button = switchEl.children('.switch-button'),

			// Is it a mini/tiny switch
			mini = switchEl.hasClass('mini'),
			tiny = switchEl.hasClass('tiny'),

			// Size adjustments
			buttonOverflow = tiny ? 2 : 0,
			valuesOverflow = ((mini || tiny) ? 7 : 4)+(2*buttonOverflow),
			marginIE7 = ($.template.ie7 && !mini && !tiny) ? 4 : 0,

			// Original button position
			initialPosition = button.position().left,

			// Inner elements
			onEl = switchEl.children('.switch-on'),
			onSpan = onEl.children(),
			offEl = switchEl.children('.switch-off'),
			offSpan = offEl.children(),

			// Available space
			switchWidth = switchEl.width(),
			buttonWidth = button.outerWidth(true),
			availableSpace = switchWidth-buttonWidth+(2*buttonOverflow),

			// Type of event
			touchEvent = (event.type === 'touchstart'),

			// Event start position
			offsetHolder = touchEvent ? event.originalEvent.touches[0] : event,
			mouseX = offsetHolder.pageX,

			// Work vars
			ieSelectStart, dragged = false, value;

		// If not valid, exit
		if (!replaced || replaced.length === 0)
		{
			return;
		}

		// Do not handle if disabled
		if (switchEl.closest('.disabled').length || replaced.is(':disabled'))
		{
			return;
		}

		// Stop text selection
		event.preventDefault();
		ieSelectStart = document.onselectstart;
		document.onselectstart = function()
		{
			return false;
		};

		// Add class to prevent animation
		switchEl.addClass('dragging');

		// Watch mouse/finger move
		function watchMouse(event)
		{
			var offsetHolder = touchEvent ? event.originalEvent.touches[0] : event,
				position = Math.max(0, Math.min(availableSpace, initialPosition+(offsetHolder.pageX-mouseX)));

			// Actual value
			value = (position > availableSpace/2) ? !reversed : reversed;

			// Move inner elements
			if (reversed)
			{
				button.css('right', (availableSpace-position-buttonOverflow)+'px');
				offEl.css('right', (switchWidth-position-valuesOverflow)+'px');
				offSpan.css('margin-left', -(availableSpace-position+marginIE7)+'px');
				onEl.css('left', (buttonWidth+position-valuesOverflow)+'px');
			}
			else
			{
				button.css('left', (position-buttonOverflow)+'px');
				onEl.css('right', (switchWidth-position-valuesOverflow)+'px');
				onSpan.css('margin-left', -(availableSpace-position+marginIE7)+'px');
				offEl.css('left', (buttonWidth+position-valuesOverflow)+'px');
			}

			// Drag is effective
			dragged = true;
		}
		doc.on(touchEvent ? 'touchmove' : 'mousemove', watchMouse);

		// Watch for mouseup/touchend
		function endDrag()
		{
			doc.off(touchEvent ? 'touchmove' : 'mousemove', watchMouse);
			doc.off(touchEvent ? 'touchend' : 'mouseup', endDrag);

			// Remove class preventing animation
			switchEl.removeClass('dragging');

			// Reset positions
			if (reversed)
			{
				button.css('right', '');
				offEl.css('right', '');
				offSpan.css('margin-left', '');
				onEl.css('left', '');
			}
			else
			{
				button.css('left', '');
				onEl.css('right', '');
				onSpan.css('margin-left', '');
				offEl.css('left', '');
			}

			// Re-enable text selection
			document.onselectstart = ieSelectStart ? ieSelectStart : null;

			// If dragged, update value
			if (dragged)
			{
				// Set new value
				if (replaced.prop('checked') != value)
				{
					replaced.prop('checked', value).change();
				}

				// Prevent change on upcoming click event
				switchEl.data('switch-dragged', true);
				setTimeout(function()
				{
					switchEl.removeData('switch-dragged');

				}, 40);
			}
			else if (touchEvent)
			{
				// Click event is not trigerred for touch devices when touch events were handled
				switchEl.click();
			}
		}
		doc.on(touchEvent ? 'touchend' : 'mouseup', endDrag);
	});

	// Radios and checkboxes changes
	doc.on('change silent-change', ':radio, :checkbox', function(event)
	{
		var element = $(this),
			replacement = element.data('replacement'),
			checked = this.checked;

		// Update visual style
		if (replacement)
		{
			// Update style
			replacement[checked ? 'addClass' : 'removeClass']('checked');
		}
		// Button labels
		else if (element.parent().is('label.button'))
		{
			element.parent()[checked ? 'addClass' : 'removeClass']('active');
		}

		// If radio, refresh others without triggering 'change'
		if (this.type === 'radio')
		{
			$('input[name="'+this.name+'"]:radio').not(this).each(function(i)
			{
				var input = $(this),
					replacement = input.data('replacement');

				// Switch
				if (replacement)
				{
					replacement[this.checked ? 'addClass' : 'removeClass']('checked');
				}
				// Button labels
				else if (input.parent().is('label.button'))
				{
					input.parent()[this.checked ? 'addClass' : 'removeClass']('active');
				}
			});
		}
	});

	// Switches, radios and checkboxes focus
	doc.on('focus', 'span.switch, span.radio, span.checkbox', function(event)
	{
		var element = $(this),
			replaced = element.data('replaced'),
			handleKeysEvents = false;

		// If not valid, exit
		if (!replaced || replaced.length === 0)
		{
			return;
		}

		// Do not handle if disabled
		if (element.closest('.disabled').length > 0 || replaced.is(':disabled'))
		{
			event.preventDefault();
			return;
		}

		// IE7-8 focus handle is different from modern browsers
		if ($.template.ie7 || $.template.ie8)
		{
			//doc.find('.focus').not(element).blur();
		}

		// Show focus
		element.addClass('focus');

		/*
		 * Keyboard events handling
		 */
		handleKeysEvents = function(event)
		{
			if (event.keyCode == $.template.keys.space)
			{
				// If radio, do not allow uncheck as this may leave all radios unchecked
				if (!replaced.is(':radio') || !replaced[0].checked)
				{
					// Change replaced state, listener will update style
					replaced[0].checked = !replaced[0].checked;
					replaced.change();
				}
				event.preventDefault();
			}
		};

		// Blur function
		function onBlur()
		{
			// Remove styling
			element.removeClass('focus');

			// Clear data
			element.removeData('checkableBlurFunction');

			// Stop listening
			doc.off('keydown', handleKeysEvents);
			element.off('blur', onBlur);
		}

		// Store for external calls
		element.data('checkableBlurFunction', onBlur);

		// Start listening
		element.on('blur', onBlur);
		doc.on('keydown', handleKeysEvents);
	});

	// Textareas focus
	doc.on('focus', 'textarea', function(event)
	{
		var element = $(this);

		// Fixes the focus issues on some browsers
		//doc.find('.focus').not(element).blur();

		// Styling
		element.addClass('focus');

	}).on('blur', 'textarea', function()
	{
		$(this).removeClass('focus');
	});

	// Inputs focus
	doc.on('focus', 'input', function(event)
	{
		var input = $(this),
			replacement, wrapper,
			last;

		// Do not handle if disabled
		if (input.closest('.disabled').length > 0 || input.is(':disabled'))
		{
			event.preventDefault();
			return;
		}

		// For radios and focus, pass focus to replacement element
		if (this.type === 'radio' || this.type === 'checkbox')
		{
			replacement = input.data('replacement');

			// Update visual style
			if (replacement)
			{
				replacement.addClass('focus');
			}

			// Done, even if no replacement
			return;
		}

		// Fixes the focus issues on some browsers
		//doc.find('.focus').not(input).blur();

		// Placeholder polyfill
		if (!Modernizr.input.placeholder && input.attr('placeholder') && input.val() === input.attr('placeholder'))
		{
			input.removeClass('placeholder').val('');
		}

		// Look for wrapped inputs
		wrapper = input.closest('.input, .inputs');

		// If wrapped
		if (wrapper.length > 0)
		{
			// Styling
			wrapper.addClass('focus');

			// For number inputs
			if (wrapper.hasClass('number'))
			{
				// Watch keydown
				input.on('keydown.number', function(event)
				{
					// If up and down
					if (event.which === 38 || event.which === 40)
					{
						input.incrementNumber((event.which === 38), event.shiftKey);
					}
				});

				// Watch keyup
				input.on('keyup.number', function(event)
				{
					var value = input.val();

					// Only trigger change if the content has changed
					if (value === last)
					{
						return;
					}

					// Update slider
					input.trigger('change');

					// Store for next check
					last = value;
				});
			}
		}
		else
		{
			// Styling
			input.addClass('focus');
		}

	}).on('blur', 'input', function()
	{
		var input = $(this),
			replacement,
			wrapper;

		// Not for radios and checkboxes
		if (this.type === 'radio' || this.type === 'checkbox')
		{
			replacement = input.data('replacement');

			// Update visual style
			if (replacement)
			{
				replacement.removeClass('focus');
			}

			// Done, even if no replacement
			return;
		}

		// Placeholder polyfill
		if (!Modernizr.input.placeholder && input.attr('placeholder') && input.val() === '' && input.attr('type') != 'password')
		{
			input.addClass('placeholder').val(input.attr('placeholder'));
		}

		// Remove styling
		wrapper = input.closest('.focus');
		wrapper.removeClass('focus');

		// For number inputs
		if (wrapper.hasClass('number'))
		{
			// Stop watching keyboard events
			input.off('keydown.number').off('keyup.number');

			// Validate value
			input.setNumber(input.val());
		}
	});

	// Placehoder support
	if (!Modernizr.input.placeholder)
	{
		// Empty placehoder on form submit
		doc.on('submit', 'form', function(event)
		{
			$(this).find('input.placeholder').each(function()
			{
				var input = $(this);

				if (input.attr('placeholder') && input.val() === input.attr('placeholder'))
				{
					input.val('');
				}
			});
		});
	}

	// File inputs
	doc.on('change silent-change', '.file > input[type="file"]', function(event)
	{
		var input = $(this),
			files = [], text, i;

		// Update styling text
		if (this.multiple && this.files)
		{
			for (i = 0; i < this.files.length; i++)
			{
				files.push(this.files[i].name.split(/(\/|\\)/).pop());
			}
			text = files.join(', ');
		}
		else
		{
			text = input.val().split(/(\/|\\)/).pop();
		}

		// Set text
		input.siblings('.file-text').text(text);
	});

	// Value inputs
	doc.on('click', '.number-up, .number-down', function(event)
	{
		var button = $(this),
			wrapper = button.parent(),
			input = wrapper.children('input:first'),
			value;

		// Check if valid
		if (input.length === 0 || input.is(':disabled'))
		{
			return;
		}

		// Increment
		input.incrementNumber(button.hasClass('number-up'), event.shiftKey).focus().trigger('change');
	});

	// Scroll on value inputs
	doc.on('mousewheel', '.number', function(event, delta, deltaX, deltaY)
	{
		var input = $(this).find('input');

		// Check if valid
		if (!input.length || input.is(':disabled'))
		{
			return;
		}

		// Change value
		input.incrementNumber(delta > 0, event.shiftKey).focus().trigger('change');

		// Prevent parents from scrolling
		event.preventDefault();
	});

	// Handle native select focus
	doc.on('focus', '.select > select', function()
	{
		var select = $(this),
			replacement = select.data('replacement');
		if (replacement)
		{
			if (replacement.hasClass('select-styled-list'))
			{
				replacement.focus();
			}
			else
			{
				replacement.hasClass('focus');
				select.one('blur', function()
				{
					replacement.removeClass('focus');
				});
			}
		}
	});
	doc.on('focus select-focus', 'span.select, span.selectMultiple', function(event)
	{
		// Only work if the element is the event's target
		if (event.target !== this)
		{
			return;
		}

		var select = $(this).closest('.select, .selectMultiple'),
			settings = select.data('select-settings') || {},
			replaced = select.data('replaced'),
			handleKeysEvents, search = '',
			blurTimeout, searchTimeout;

		// Do not handle clones
		if (select.hasClass('select-clone'))
		{
			return;
		}

		// Do not handle for non-styled lists
		if (replaced && !select.hasClass('select-styled-list'))
		{
			replaced.focus();
			return;
		}

		// Do not handle if disabled
		if (select.closest('.disabled').length > 0 || (replaced && replaced.is(':disabled')))
		{
			event.preventDefault();
			return;
		}

		// Handle really close blur/focus events
		blurTimeout = select.data('selectBlurTimeout');
		if (blurTimeout)
		{
			// The select is still focused but about to blur, prevent and remain focused
			clearTimeout(blurTimeout);
			select.removeData('selectBlurTimeout');
			return;
		}

		// Do not handle if already focused
		if (select.hasClass('focus'))
		{
			return;
		}

		// Fixes the focus issues on some browsers
		//doc.find('.focus').not(select).blur();

		// Visual style
		select.addClass('focus');

		/**
		 * Keyboard events handling
		 */

		// Affect original element, listeners will update the replacement
		handleKeysEvents = function(event)
		{
			var keys = $.template.keys,
				target = select.data('clone') || select,
				list = target.children('.drop-down'),
				selectedIndex, mode,
				focus, next, replacedOption,
				character, searchRegex;

			// If using easy multiple selection, use focus instead of selection
			mode = select.hasClass('easy-multiple-selection') ? 'focus' : 'selected';

			// Key handling
			switch (event.keyCode)
			{
				case keys.up:
					// If open or multiple, work on displayed options
					if (target.hasClass('open') || select.hasClass('selectMultiple'))
					{
						// Focused element
						focus = list.children('.'+mode+':first');
						if (focus.length === 0)
						{
							next = list.children('a, span').not('.disabled').last();
						}
						else
						{
							next = focus.prevAll('a, span').not('.disabled').first();
						}

						// Focus previous option
						if (next.length > 0)
						{
							focus.removeClass(mode);
							next.addClass(mode);
							if ($.fn.scrollToReveal)
							{
								next.scrollToReveal();
							}

							// If selection mode, update replaced and trigger change
							if (mode === 'selected' && replaced)
							{
								replacedOption = next.data('select-value');
								if (replacedOption)
								{
									// If multiple selection, clear all before
									if (replaced[0].multiple)
									{
										replaced.find('option:selected').prop('selected', false);
									}

									replacedOption.selected = true;
									replaced.trigger('change');
								}
							}
						}

						event.preventDefault();
					}
					// If replacement
					else if (replaced)
					{
						// Update original, listeners will update the replacement
						selectedIndex = _getSelectedIndex(replaced);
						if (selectedIndex !== false)
						{
							while (selectedIndex > 0)
							{
								// Make sure it is not disabled
								if (!replaced[0].options[selectedIndex-1].disabled)
								{
									replaced[0].selectedIndex = selectedIndex-1;
									replaced.change();
									break;
								}

								// Else, next option
								--selectedIndex;
							}
						}
						event.preventDefault();
					}
					break;

				case keys.down:
					// If not open yet, check if we have to
					if (select.hasClass('select') && !target.hasClass('open') && settings.openOnKeyDown)
					{
						_openSelect(select);
						event.preventDefault();
					}
					else
					{
						// If open or multiple, work on displayed options
						if (target.hasClass('open') || select.hasClass('selectMultiple'))
						{
							// Focused element
							focus = list.children('.'+mode+':last');
							if (focus.length === 0)
							{
								next = list.children('a, span').not('.disabled').first();
							}
							else
							{
								next = focus.nextAll('a, span').not('.disabled').first();
							}

							// Focus next option
							if (next.length > 0)
							{
								focus.removeClass(mode);
								next.addClass(mode);
								if ($.fn.scrollToReveal)
								{
									next.scrollToReveal();
								}

								// If selection mode, update replaced and trigger change
								if (mode === 'selected' && replaced)
								{
									replacedOption = next.data('select-value');
									if (replacedOption)
									{
										// If multiple selection, clear all before
										if (replaced[0].multiple)
										{
											replaced.find('option:selected').prop('selected', false);
										}

										replacedOption.selected = true;
										replaced.trigger('change');
									}
								}
							}

							event.preventDefault();
						}
						// If replacement
						else if (replaced)
						{
							// Update original, listeners will update the replacement
							selectedIndex = _getSelectedIndex(replaced);
							if (selectedIndex !== false)
							{
								while (selectedIndex < replaced[0].options.length-1)
								{
									// Make sure it is not disabled
									if (!replaced[0].options[selectedIndex+1].disabled)
									{
										replaced[0].selectedIndex = selectedIndex+1;
										replaced.change();
										break;
									}

									// Else, next option
									++selectedIndex;
								}
							}
							event.preventDefault();
						}
					}
					break;

				case keys.enter:
				case keys.space:
					// If focus mode on, simulate click
					if (mode === 'focus' && (select.hasClass('selectMultiple') || target.hasClass('open')))
					{
						// Focused element
						focus = list.children('.'+mode);
						if (focus.length === 1)
						{
							event.preventDefault();
							focus.click();
						}
					}
					// Else, just close the select if open
					else if (target.hasClass('open'))
					{
						target.trigger('close-select');
					}
					break;

				default:
					// Get pressed key character
					character = String.fromCharCode(event.keyCode);

					// If regular character
					if (character && character.length === 1)
					{
						// If a search timeout is in, stop it
						if (searchTimeout)
						{
							clearTimeout(searchTimeout);
						}

						// Add to search
						search += character.toLowerCase();
						searchRegex = new RegExp('^'+search, 'g');

						// Start timeout to clear search string when no more key are pressed
						searchTimeout = setTimeout(function()
						{
							search = '';

						}, 1500);

						// Mode
						if (target.hasClass('open') || select.hasClass('selectMultiple'))
						{
							// Loop through values to find a match
							list.children('a, span').each(function(i)
							{
								var option = $(this);

								// If matches
								if ($.trim(option.text().toLowerCase()).match(searchRegex))
								{
									// Focused element
									focus = list.children('.'+mode+':last');

									// Focus option
									focus.removeClass(mode);
									option.addClass(mode);
									if ($.fn.scrollToReveal)
									{
										option.scrollToReveal();
									}

									// If selection mode, update replaced and trigger change
									if (mode === 'selected' && replaced)
									{
										replacedOption = option.data('select-value');
										if (replacedOption)
										{
											// Set value
											replaced.val(replacedOption.value).trigger('change');
										}
									}

									// Prevent default key event
									event.preventDefault();

									// Stop search
									return false;
								}
							});
						}
						// Closed mode only works for replacements
						else if (replaced)
						{
							// Loop through values to find a match
							replaced.find('option').each(function(i)
							{
								// If matches
								if ($.trim($(this).text().toLowerCase()).match(searchRegex))
								{
									// Set value
									replaced.val(this.value).trigger('change');

									// Prevent default key event
									event.preventDefault();

									// Stop search
									return false;
								}
							});
						}
					}
					break;
			}
		};

		// Blur function
		function onBlur(event, timed)
		{
			var target = $(event.target),
				clone = select.data('clone');

			// If this is an internal operation, do not process
			if (select.data('select-hiding'))
			{
				return;
			}

			// Validation for click/touchend event
			if ((event.type === 'click' || event.type === 'touchend') && (target.closest(select).length || (clone && target.closest(clone).length)))
			{
				return;
			}

			// Handle really close blur/focus events
			blurTimeout = select.data('selectBlurTimeout');
			if (!blurTimeout)
			{
				// Wait, are you sure you want me to blur? Let's just wait a little...
				select.data('selectBlurTimeout', setTimeout(function() { onBlur.call(this, event, true); }, 40));
				return;
			}
			else if (timed)
			{
				// The blur timeout has ended without getting back focus, so let's blur!
				select.removeData('selectBlurTimeout');
			}
			else
			{
				// Multiple blur events, do not handle
				return;
			}

			// Close if open
			select.trigger('close-select');

			// Remove styling
			select.removeClass('focus');

			// Stop listening
			doc.off('focusin', onFocusin);
			doc.off('keydown', handleKeysEvents);
			doc.off('click', onBlur);
			select.off('blur', onBlur);
		}

		// Watch focus on other elements
		function onFocusin(event)
		{
			var target = $(event.target),
				clone = select.data('clone');

			// Check if focus target is within the select
			if (target.closest(select).length || (clone && target.closest(clone).length))
			{
				// Pseudo-focus to preserve styling and key events
				select.trigger('select-focus');
			}
			else
			{
				// Handle focus on another input while waiting to refocus a select
				blurTimeout = select.data('selectBlurTimeout');
				if (blurTimeout)
				{
					clearTimeout(blurTimeout);
				}
				onBlur.call(this, event, true);
			}
		}

		// Start listening
		select.on('blur', onBlur);
		doc.on('touchend click', onBlur);
		doc.on('keydown', handleKeysEvents);
		doc.on('focusin', onFocusin);
	});

	// Handle select change
	doc.on('change silent-change', 'select', function()
	{
		var replaced = $(this),
			select = replaced.data('replacement');

		// If valid
		if (select)
		{
			_updateSelectText(select, replaced, select.data('select-settings'));
		}
	});

	// Opening when on touch device
	if ($.template.touchOs)
	{
		// Open on tap
		doc.on('touchend', '.select-arrow, span.select-value', function(event)
		{
			_openSelect($(this).parent(), false, event);
		});
	}
	else
	{
		// Selects opening arrow
		doc.on('click', '.select-arrow, span.select-value', function(event)
		{
			var select = $(this).parent();
			if (!select.hasClass('select-clone') && !select.hasClass('auto-open'))
			{
				_openSelect(select, false, event);
			}
		});

		// Auto-opening selects
		doc.on('mouseenter', '.select.auto-open', function(event)
		{
			var select = $(this);
			if (!select.hasClass('select-clone'))
			{
				_openSelect($(this), true, event);
			}
		});
	}

	/*
	 * Form validation hooks:
	 * The replaced selects need to be un-hidden to be validated, then hidden back
	 */
	doc.on('jqv.form.validating', 'form', function(event)
	{
		var form = $(this),
			hidden = form.find('span.select > select, span.selectMultiple > select').filter(':hidden').show(),

			// Return to normal state
			validateEnd = function()
			{
				hidden.css('display', '');
				form.off('jqv.form.result', validateEnd);
			};

		// Listen for end of validation
		form.on('jqv.form.result', validateEnd);
	});

})(jQuery, window, document);
 /**
 *     ___ _    __   ____            _
 *    /   | |  / /  / __ \___  _____(_)____ ____ 
 *   / /| | | / /  / / / / _ \/ ___/ / __ `/ __ \
 *  / ___ | |/ /  / /_/ /  __(__  ) / /_/ / / / /
 * /_/  |_|___/  /_____/\___/____/_/\__, /_/ /_/ 
 *                                 /____/        
 * ------------ By Anselmo Velame --------------- 
 *
 * funtions global do sistema
 * Boas prticas estruturais dos padres essenciais para usar os plugins 
 */

/*
 * The semi-colon before the function invocation is a safety
 * net against concatenated scripts and/or other plugins
 * that are not closed properly.
 */
;(function($, undefined)
{
	/*
	 * undefined is used here as the undefined global variable in ECMAScript 3 is mutable (i.e. it can
	 * be changed by someone else). undefined isn't really being passed in so we can ensure that its value is
	 * truly undefined. In ES5, undefined can no longer be modified.
	 */

	/**
	 * Display a message on the target element
	 *
	 * @param string message the text or html message to display
	 * @param object options - optional (see defaults for a complete list)
	 * @return jQuery the messages nodes
	 */
	$.fn.message = function(message, options)
	{
		// Settings
		var globalSettings = $.extend({}, $.fn.message.defaults, options),
			all;

		// Insert message
		all = $();
		this.each(function(i)
		{
			var target = $(this),
				settings = $.extend({}, globalSettings, target.data('message-options')),
				classes = ['message'].concat(settings.classes),
				onTop = (settings.position.toLowerCase() != 'bottom'),
				method = onTop ? (settings.append ? 'prependTo' : 'insertBefore') : (settings.append ? 'appendTo' : 'insertAfter'),
				link = (settings.node.toLowerCase() === 'a') ? ' href="'+settings.link+'"' : '',

				// Extra elements
				simpler = settings.simpler ? ' simpler' : '',
				inset = settings.inset ? ' inset' : '',
				closeOnHover = settings.showCloseOnHover ? ' show-on-parent-hover' : '',
				closeButton = settings.closable ? '<span class="close'+inset+closeOnHover+simpler+'"></span>' : '',
				useArrow = (settings.arrow && $.inArray(settings.arrow.toLowerCase(), ['top', 'right', 'bottom', 'left']) > -1),
				arrow = useArrow ? '<span class="block-arrow '+settings.arrow.toLowerCase()+'"><span></span></span>' : '',

				// Other vars
				stripesSize, animatedStripes, darkStripes, stripes = '',
				element, previous, found = false, count;

			// If similar messages should be grouped
			if (settings.groupSimilar)
			{
				// Gather previous messages
				if (settings.append)
				{
					previous = target.childrenImmediates('.message', !onTop).not('.closing');
				}
				else
				{
					previous = target[onTop ? 'prevImmediates' : 'nextImmediates']('.message').not('.closing');
				}

				// Check if a similar message exists
				previous.each(function(i)
				{
					var element = $(this);
					if (element.data('message-text') === message)
					{
						found = element;
						return false;
					}
				});
				if (found)
				{
					// Count
					if (settings.groupCount)
					{
						// Check if count element already exists
						count = found.children('.count');
						if (count.length > 0)
						{
							count.text((parseInt(count.text(), 10) || 1)+1);
						}
						else
						{
							found.append('<span class="count left'+inset+'">2</span>');
						}
					}

					// Effect
					found.shake();

					all = all.add(found);
					return found;
				}
			}

			// Stripes
			if (settings.stripes)
			{
				// Dark or not
				darkStripes = settings.darkStripes ? 'dark-' : '';

				// Size
				stripesSize = (settings.stripesSize === 'big' || settings.stripesSize === 'thin') ? settings.stripesSize+'-' : '';

				// Animated
				animatedStripes = settings.animatedStripes ? ' animated' : '';

				// Final
				stripes = '<span class="'+darkStripes+stripesSize+'stripes'+animatedStripes+'"></span>';
			}

			// Insert
			element = $('<'+settings.node+link+' class="'+classes.join(' ')+simpler+'">'+stripes+message+closeButton+arrow+'</'+settings.node+'>')[method](target);

			// Store message for later comparisons
			element.data('message-text', message);

			// Add to selections
			target.data('messages', (target.data('messages') || $()).add(element));
			all = all.add(element);

			// Effect
			if (settings.animate)
			{
				element.hide().slideDown(settings.animateSpeed);
			}

			// Delay
			if (settings.autoClose)
			{
				setTimeout(function()
				{
					element.foldAndRemove();

				}, settings.autoClose);
			}
		});

		return all;
	};

	/**
	 * Clear element's message(s)
	 *
	 * @param string message the message to remove (can be omitted)
	 * @param boolean animate use an animation (foldAndRemove) to remove the messages (default: false)
	 * @return jQuery the chain
	 */
	$.fn.clearMessages = function(message, animate)
	{
		// Params
		if (typeof message === 'boolean')
		{
			animate = message;
			message = '';
		}
		animate = (animate || animate === undefined);

		this.each(function(i)
		{
			var messages = $(this).data('messages'),
				removed;
			if (messages)
			{
				// If specific message only
				if (message && message.length > 0)
				{
					removed = $();
					messages.each(function(i)
					{
						if ($(this).data('message-text') === message)
						{
							removed = removed.add(this);
						}
					});
				}
				else
				{
					// Remove all
					removed = messages;
				}

				// Remove
				removed.addClass('closing')[animate ? 'foldAndRemove' : 'remove']();

				// Update/clear data
				if (removed.length === messages.length)
				{
					$(this).removeData('messages');
				}
				else
				{
					$(this).data('messages', messages.not(removed));
				}
			}
		});

		return this;
	};

	/**
	 * Message function defaults
	 * @var object
	 */
	$.fn.message.defaults = {

		/**
		 * Whether to append the message element or to insert it next to the target
		 * @var boolean
		 */
		append: true,

		/**
		 * Position in or next the target: 'top' or 'bottom'
		 * @var string
		 */
		position: 'top',

		/**
		 * Arrow direction or false for none
		 * @var string|boolean
		 */
		arrow: false,

		/**
		 * Node type for the message (tip: 'p' has bottom-margin, 'a' and 'div' have none)
		 * @var string
		 */
		node: 'p',

		/**
		 * Link when the node type is 'a'
		 * @var string
		 */
		link: '#',

		/**
		 * Extra classes (colors...)
		 * @var array
		 */
		classes: [],

		/**
		 * Enable animated stripes
		 * @var boolean
		 */
		stripes: false,

		/**
		 * True for animated stripes (only on compatible browsers)
		 * @var boolean
		 */
		animatedStripes: true,

		/**
		 * True for dark stripes, false for white stripes
		 * @var boolean
		 */
		darkStripes: true,

		/**
		 * Stripes size: 'big', 'normal' or 'thin'
		 * @var string
		 */
		stripesSize: 'normal',

		/**
		 * Use true to remove rounded corners and bewel
		 * @var boolean
		 */
		simpler: false,

		/**
		 * Enable a close button
		 * @var boolean
		 */
		closable: true,

		/**
		 * Show the close button only on hover
		 * @var boolean
		 */
		showCloseOnHover: true,

		/**
		 * Animate the message's occurrence
		 * @var boolean
		 */
		animate: true,

		/**
		 * Speed of animation (any jQuery valid value)
		 * @var string|int
		 */
		animateSpeed: 'fast',

		/**
		 * Group similar messages
		 * @var boolean
		 */
		groupSimilar: true,

		/**
		 * Display a bubble with the count of grouped messages
		 * @var boolean
		 */
		groupCount: true,

		/**
		 * Should close and count bubbles be inside the message?
		 * @var boolean
		 */
		inset: false,

		/**
		 * Auto-close after specified delay (in milliseconds), or false to disable
		 * @var int|boolean
		 */
		autoClose: false

	};

})(jQuery);
 /**
 *     ___ _    __   ____            _
 *    /   | |  / /  / __ \___  _____(_)____ ____ 
 *   / /| | | / /  / / / / _ \/ ___/ / __ `/ __ \
 *  / ___ | |/ /  / /_/ /  __(__  ) / /_/ / / / /
 * /_/  |_|___/  /_____/\___/____/_/\__, /_/ /_/ 
 *                                 /____/        
 * ------------ By Anselmo Velame --------------- 
 *
 * funtions global do sistema
 * Boas prticas estruturais dos padres essenciais para usar os plugins 
 */

/*
 * The semi-colon before the function invocation is a safety
 * net against concatenated scripts and/or other plugins
 * that are not closed properly.
 */
;(function($, window, document, undefined)
{
	/*
	 * undefined is used here as the undefined global variable in ECMAScript 3 is mutable (i.e. it can
	 * be changed by someone else). undefined isn't really being passed in so we can ensure that its value is
	 * truly undefined. In ES5, undefined can no longer be modified.
	 */

	/*
	 * window and document are passed through as local variables rather than as globals, because this (slightly)
	 * quickens the resolution process and can be more efficiently minified.
	 */

	// Objects cache
	var doc = $(document);

	/**
	 * Internal reference: the div holding top notifications
	 * @var jQuery
	 */
	var _topNotificationDiv = false;

	/**
	 * Internal function: retrieve the div holding top notifications
	 *
	 * @return jQuery the div selection
	 */
	function _getTopNotificationDiv()
	{
		if (!_topNotificationDiv)
		{
			_topNotificationDiv = $('<div id="top-notifications"></div>').appendTo(document.body);
		}

		return _topNotificationDiv;
	}

	/**
	 * Internal reference: the div holding bottom notifications
	 * @var jQuery
	 */
	var _bottomNotificationDiv = false;

	/**
	 * Internal function: retrieve the div holding bottom notifications
	 *
	 * @return jQuery the div selection
	 */
	function _getBottomNotificationDiv()
	{
		if (!_bottomNotificationDiv)
		{
			_bottomNotificationDiv = $('<div id="bottom-notifications"></div>').appendTo(document.body);
		}

		return _bottomNotificationDiv;
	}

	/**
	 * Internal function: output archived notifications
	 *
	 * @param jQuery element the archive element
	 * @param int max the max number of output messages
	 * @param object settings the notify options
	 * @return boolean true if there are some more notifications, else false
	 */
	function _releaseNotices(element, max, settings)
	{
		var archive = element.data('notifications-archive') || [],
			releaseCount = (max > 0) ? Math.min(archive.length, max) : archive.length,
			i, archived;

		// Release messages
		for (i = 0; i < releaseCount; ++i)
		{
			archived = archive.shift();
			window.notify(archived.title, archived.message, $.extend(archived.options, { delay: i*100 }), true);
		}

		// If archive is now empty, clear waiting message block
		if (archive.length === 0)
		{
			element.remove();
			return false;
		}
		else
		{
			// Update number of waiting messages
			archiveSize = archive.length;
			element.text((archiveSize > 1) ? settings.textSeveralMore.replace('%d', archiveSize) : settings.textOneMore);
			return true;
		}
	};

	/**
	 * Internal function: activate notification auto close
	 *
	 * @param jQuery element the notification element
	 * @param int delay delay before the notification closes
	 * @return void
	 */
	function _activateNoticeAutoClose(element, delay)
	{
		// Timer
		element.data('notification-timeout', setTimeout(function() { element.fadeAndRemove().trigger('close'); }, delay));

		// Prevent closing when hover
		element.hover(function()
		{
			clearTimeout(element.data('notification-timeout'));

		}, function()
		{
			element.data('notification-timeout', setTimeout(function() { element.fadeAndRemove().trigger('close'); }, delay));
		});
	};

	/**
	 * Display a notification. If the page is not yet ready, delay the notification until it is ready.
	 *
	 * @var string title the title - can be omitted
	 * @var string message a text or html message to display
	 * @var object options an object with any options for the message - optional (see defaults for more details)
	 * @var boolean rotate force deletion of older element before inserting new one - optional (internal mostly, but can be used if relevant)
	 * @return void
	 */
	window.notify = function(title, message, options, rotate)
	{
		// Parameters
		if (message == undefined || typeof message === 'object')
		{
			options = message || {};
			message = title;
			title = '';
		}

		// Defaults
		options = options || {};
		rotate = rotate || false;

		// If the document is not ready or we want some delay
		if (!$.isReady || (options != undefined && options.delay > 0))
		{
			// Delay action
			var delay = (options != undefined) ? (options.delay || 40) : 40;
			setTimeout(function() { window.notify(title, message, $.extend(options, { delay: 0 }), rotate); }, delay);
		}
		else
		{
			// Position defaults
			if (!options.vPos)
			{
				options.vPos = window.notify.defaults.vPos;
			}
			if (!options.hPos)
			{
				options.hPos = window.notify.defaults.hPos;
			}

			var settings = $.extend({},
							// Global defaults
							window.notify.defaults,
							// Defaults for vertical position
							window.notify.defaults[options.vPos.toLowerCase()],
							// Defaults for horizontal position
							window.notify.defaults[options.hPos.toLowerCase()],
							// Defaults for final position
							window.notify.defaults[options.vPos.toLowerCase()+options.hPos.toLowerCase()],
							// User options
							options);

			// System notification
			if (settings.system && window.notify.hasNotificationPermission())
			{
				var notifTitle = ($.trim(title).length > 0) ? title : document.title,
					notification = window.webkitNotifications.createNotification(settings.icon || '', notifTitle, message);

				// Display event
				if (settings.autoClose || settings.onDisplay)
				{
					notification.ondisplay = function()
					{
						// Callback
						if (settings.onDisplay)
						{
							settings.onDisplay.call(notification);
						}

						// Auto-close after delay
						if (settings.autoClose)
						{
							setTimeout(function () { notification.cancel(); }, settings.closeDelay);
						}
					};
				}

				// Click event
				if ((settings.link && settings.link.length > 0) || settings.onClick)
				{
					notification.onclick = function()
					{
						// Callback
						if (settings.onClick)
						{
							settings.onClick.call(notification);
						}

						// Redirection
						if (settings.link && settings.link.length > 0)
						{
							notification.cancel();
							document.location.href = settings.link;
						}
					};
				}

				// Close event
				if (settings.onClose)
				{
					notification.onclose = function()
					{
						// Callback
						settings.onClose.call(notification);
					};
				}

				// Error handling
				notification.onerror = function()
				{
					// If a callback is provided
					if (settings.onError)
					{
						if (settings.onError.call(notification) === false)
						{
							return;
						}
					}

					// Fallback on standard notification
					window.notify(title, message, $.extend(settings, { system: false }), rotate);
				};

				// Show notification
				notification.show();

				// Done for now
				return;
			}

			var classes = ['notification'].concat(settings.classes),
				listId = 'notifications-'+settings.vPos.toLowerCase()+'-'+settings.hPos.toLowerCase(),
				list = $('#'+listId),
				icon = (settings.icon && settings.icon.length > 0) ? '<img class="notification-icon'+(settings.iconOutside ? ' outside' : '')+'" src="'+settings.icon+'">' : '',
				iconArrowSide = (settings.hPos.toLowerCase() === 'left') ? 'right' : 'left',
				iconArrow = (icon.length > 0 && settings.iconOutside) ? '<span class="block-arrow '+iconArrowSide+'"><span></span></span>' : '',
				closeButton = settings.closeButton ? '<span class="close'+(settings.showCloseOnHover ? ' show-on-parent-hover' : '')+'"></span>' : '',
				elementTitle = ($.trim(title).length > 0) ? '<h3>'+title+'</h3>' : '',
				altTitle = (settings.title.length > 0) ? ' title="'+settings.title+'"' :'',
				wrapperOpen = (settings.link.length > 0) ? '<a href="'+settings.link+'"'+altTitle+'>' :'<div'+altTitle+'>',
				wrapperClose = (settings.link.length > 0) ? '</a>' :'</div>',
				postponed = false,
				more = list.children('.more-notifications'),
				siblings, block, element, effectMargins;

			// Target list
			if (list.length === 0)
			{
				// Create list
				list = $('<ul id="'+listId+'"></ul>').appendTo((settings.vPos.toLowerCase() === 'top') ? _getTopNotificationDiv() : _getBottomNotificationDiv());
			}

			// List of current messages
			siblings = list.children().not('.closing').not('.more-notifications');

			// If grouping similar messages, check if another one is still displayed
			if (settings.groupSimilar)
			{
				siblings.each(function(i)
				{
					var previous = $(this),
						data = previous.data('notification-data'),
						extras, timeout, archive, archiveSize;

					// Compare messages
					if (data.title === title.toLowerCase() && data.message === message.toLowerCase())
					{
						// Get or create the extra messages block
						extras = previous.children('.extra-notifications');
						if (extras.length > 0)
						{
							// Retrieve existing archive
							archive = extras.data('notifications-archive') || [];
						}
						else
						{
							// Create element and archive
							extras = $('<p class="extra-notifications"></p>').appendTo(previous);
							archive = [];
						}

						// Stop autoClose
						timeout = previous.data('notification-timeout');
						if (timeout)
						{
							clearTimeout(timeout);
							previous.off('mouseenter');
							previous.off('mouseleave');
						}

						// Re-apply if required
						if (!settings.stickGrouped && (timeout || settings.autoClose))
						{
							_activateNoticeAutoClose(previous, settings.closeDelay);
						}

						// Add message to queue
						archive.push({
							title: title,
							message: message,
							options: options
						});

						// Number of waiting messages
						archiveSize = archive.length;
						extras.text((archiveSize > 1) ? settings.textSeveralSimilars.replace('%d', archiveSize) : settings.textOneSimilar);

						// Save archive
						extras.data('notifications-archive', archive);

						// Effect
						if (!previous.is(':animated'))
						{
							previous.shake((doc.width() >= 768) ? 15 : 5);
						}

						// Done
						postponed = true;
						return false;
					}
				});
			}

			// Check if we exceed the simultaneous messages limit
			if (!postponed && settings.limit > 0 && siblings.length >= settings.limit)
			{
				// If rotation
				if (rotate || settings.rotate)
				{
					// Remove first
					siblings.eq(0).addClass('closing').foldAndRemove();
				}
				else
				{
					// Get or create the waiting messages block
					if (more.length > 0)
					{
						// Retrieve existing archive
						archive = more.data('notifications-archive') || [];
					}
					else
					{
						// Create element and archive
						more = $('<li class="notification more-notifications"></li>').appendTo(list);
						archive = [];

						// Behavior
						more.click(function(event)
						{
							_releaseNotices(more, settings.releaseLimit, settings);
						});
					}

					// Add message to queue
					archive.push({
						title: title,
						message: message,
						options: options
					});

					// Number of waiting messages
					archiveSize = archive.length;
					more.text((archiveSize > 1) ? settings.textSeveralMore.replace('%d', archiveSize) : settings.textOneMore);

					// Save archive
					more.data('notifications-archive', archive);

					// Done
					postponed = true;
				}
			}

			// If put in a waiting list, exit
			if (postponed)
			{
				return;
			}

			// If no title
			if ($.trim(title).length === 0)
			{
				classes.push('no-title');
			}

			// Append message
			element = $('<li class="'+classes.join(' ')+'">'+icon+iconArrow+wrapperOpen+elementTitle+message+wrapperClose+closeButton+'</li>');
			if (more.length > 0)
			{
				element.insertBefore(more).hide().slideDown();
			}
			else
			{
				element.appendTo(list).hide().fadeIn('slow');
			}

			// Display callback
			if (settings.onDisplay)
			{
				settings.onDisplay.call(element[0]);
			}

			// Function on click
			if (settings.onClick)
			{
				element.children().not('.close').on('click', settings.onClick);
			}

			// Save some data
			element.data('notification-data', {
				title: title.toLowerCase(),
				message: message.toLowerCase(),
				closeDelay: settings.closeDelay
			});

			// Watch close button
			element.on('close', function()
			{
				// Mark as closing to prevent similar messages to be added
				element.addClass('closing');

				// Check if queued messages
				var more = list.children('.more-notifications');
				if (more.length > 0)
				{
					// Change fade effect to folding
					element.stop(true).foldAndRemove();

					// Release next notification
					_releaseNotices(more, 1, settings);
				}
			});
			if (settings.onClose)
			{
				element.on('close', settings.onClose);
			}

			// If closing
			if (settings.autoClose)
			{
				_activateNoticeAutoClose(element, settings.closeDelay);
			}
		}
	};

	/**
	 * Check if the Notification API is available
	 * @return boolean true if available, else false
	 */
	window.notify.hasNotificationAPI = function()
	{
		return !!window.webkitNotifications;
	};

	/**
	 * Check if the Notification API permission is set
	 * @return boolean true if available, else false
	 */
	window.notify.isNotificationPermissionSet = function()
	{
		return (window.notify.hasNotificationAPI() && window.webkitNotifications.checkPermission() != 1); // 1 is PERMISSION_NOT_ALLOWED
	};

	/**
	 * Check if the Notification API permission is granted
	 * @return boolean true if available, else false
	 */
	window.notify.hasNotificationPermission = function()
	{
		return (window.notify.hasNotificationAPI() && window.webkitNotifications.checkPermission() == 0); // 0 is PERMISSION_ALLOWED
	};

	/**
	 * Display a message asking the user to grant permission to use the notification API
	 * Note: require the developr.message lib is required if target is not defined
	 * @param jQuery|string target the element which will be clicked to trigger the notification, or a string for a message that will be created on top of #main
	 * @param function callback a function to be called when the permission is set, granted or not (optional)
	 * @return void
	 */
	window.notify.showNotificationPermission = function(target, callback)
	{
		var message = false;

		// If not available or already granted
		if (!window.notify.hasNotificationAPI())
		{
			return;
		}

		// If no target, create a message
		if (typeof target === 'string')
		{
			if (!$.fn.message)
			{
				return;
			}

			message = $('#main').message(target, {
				node:		'a',
				classes:	['align-center', 'green-gradient'],
				simpler:	true,
				inset:		true
			});
			target = message;
		}

		// Behavior
		target.click(function(event)
		{
			// Only for target element (should no be triggered by the close button)
			if (event.target !== this)
			{
				return;
			}

			event.preventDefault();
			window.webkitNotifications.requestPermission(function()
			{
				// Remove message if needed
				if (message)
				{
					message.fadeAndRemove();
				}

				// User callback
				if (callback && typeof callback === 'function')
				{
					callback();
				}
			});
		});
	};

	/**
	 * Notify function defaults
	 * @var object
	 */
	window.notify.defaults = {
		/**
		 * Use system notification if available, else fallback on standard notifications
		 * @var boolean
		 */
		system: false,

		/**
		 * Vertical position ('top' or 'bottom')
		 * @var string
		 */
		vPos: 'top',

		/**
		 * Horizontal position ('left', 'center' or 'right')
		 * Note: ignored in mobile screens (the notification takes the full screen width)
		 * @var string
		 */
		hPos: 'right',

		/**
		 * Extra classes (colors...)
		 * @var array
		 */
		classes: [],

		/**
		 * Link on the notification
		 * @var string
		 */
		link: '',

		/**
		 * Title on hover
		 * @var string
		 */
		title: '',

		/**
		 * Icon path
		 * @var string
		 */
		icon: '',

		/**
		 * Icon should show out of the notification block? (ignored for mobile layouts)
		 * @var boolean
		 */
		iconOutside: true,

		/**
		 * Add a close button to the notification
		 * @var boolean
		 */
		closeButton: true,

		/**
		 * Show the close button only on hover
		 * @var boolean
		 */
		showCloseOnHover: true,

		/**
		 * Notice will close after (closeDelay) ms
		 * @var boolean
		 */
		autoClose: true,

		/**
		 * Delay before notification closes
		 * @var int
		 */
		closeDelay: 8000,

		/**
		 * Delay before showing the notification
		 * @var int
		 */
		delay: 0,

		/**
		 * Group similar notifications in a stack
		 * @var boolean
		 */
		groupSimilar: true,

		/**
		 * Prevent autoClose on grouped notifications
		 * @var boolean
		 */
		stickGrouped: false,

		/**
		 * Text when one similar notification is found
		 * @var boolean
		 */
		textOneSimilar: 'One similar notification',

		/**
		 * Text when several similar notifications are found
		 * Note: use %d in your string to get the final count
		 * @var boolean
		 */
		textSeveralSimilars: '%d similar notifications',

		/**
		 * Maximum number of notifications displayed at the same time in one stack
		 * Note: use 0 for no limit, but use with caution!
		 * @var int
		 */
		limit: 7,

		/**
		 * Force rotation (remove older messages) when reaching limit
		 * @var boolean
		 */
		rotate: false,

		/**
		 * Text when one similar notification is found
		 * @var boolean
		 */
		textOneMore: 'One more notification',

		/**
		 * Text when several similar notifications are found
		 * Note: use %d in your string to get the final count
		 * @var boolean
		 */
		textSeveralMore: '%d more notifications',

		/**
		 * Number of notifications released when clicking on an similiar/archive block
		 * Note: use 0 for no limit, but use with caution!
		 * @var int
		 */
		releaseLimit: 5,

		/**
		 * Options for top notifications
		 * @var object
		 */
		top: {},

		/**
		 * Options for bottom notifications
		 * @var object
		 */
		bottom: {},

		/**
		 * Options for left notifications
		 * @var object
		 */
		left: {},

		/**
		 * Options for center notifications
		 * @var object
		 */
		center: {},

		/**
		 * Options for right notifications
		 * @var object
		 */
		right: {},

		/**
		 * Options for top left notifications
		 * @var object
		 */
		topleft: {},

		/**
		 * Options for top center notifications
		 * @var object
		 */
		topcenter: {},

		/**
		 * Options for top right notifications
		 * @var object
		 */
		topright: {},

		/**
		 * Options for bottom left notifications
		 * @var object
		 */
		bottomleft: {},

		/**
		 * Options for bottom center notifications
		 * @var object
		 */
		bottomcenter: {},

		/**
		 * Options for bottom right notifications
		 * @var object
		 */
		bottomright: {},

		/**
		 * Callback when the notification is shown
		 * @var function
		 */
		onDisplay: null,

		/**
		 * Callback when the notification is clicked
		 * @var function
		 */
		onClick: null,

		/**
		 * Callback when the notification is closed
		 * @var function
		 */
		onClose: null,

		/**
		 * Callback (if using the Notification API system only) if the notification triggers an error.
		 * By default, the lib will fallback on a standard notification, the callback may return false to prevent this.
		 * @var function
		 */
		onError: null
	};

})(jQuery, window, document);
 /**
 *     ___ _    __   ____            _
 *    /   | |  / /  / __ \___  _____(_)____ ____ 
 *   / /| | | / /  / / / / _ \/ ___/ / __ `/ __ \
 *  / ___ | |/ /  / /_/ /  __(__  ) / /_/ / / / /
 * /_/  |_|___/  /_____/\___/____/_/\__, /_/ /_/ 
 *                                 /____/        
 * ------------ By Anselmo Velame --------------- 
 *
 * funtions global do sistema
 * Boas prticas estruturais dos padres essenciais para usar os plugins 
 */

/*
 * The semi-colon before the function invocation is a safety
 * net against concatenated scripts and/or other plugins
 * that are not closed properly.
 */
;(function($, window, document)
{
	/*
	 * document is passed through as local variable rather than as global, because this (slightly)
	 * quickens the resolution process and can be more efficiently minified.
	 */

		// Objects cache
	var win = $(window),
		doc = $(document),

		// Current exclusive tooltip
		exclusive = false;

	/**
	 * Internal reference: the div holding standard tooltips
	 * @var jQuery
	 */
	var _standardTooltipsDiv = false;

	/**
	 * Internal function: retrieve the div holding standard tooltips
	 *
	 * @return jQuery the div selection
	 */
	function _getStandardTooltipsDiv()
	{
		if (!_standardTooltipsDiv)
		{
			_standardTooltipsDiv = $('<div id="tooltips"></div>').appendTo(document.body);
		}

		return _standardTooltipsDiv;
	}

	/**
	 * Internal reference: the div holding tooltips over modals and notifications
	 * @var jQuery
	 */
	var _overTooltipsDiv = false;

	/**
	 * Internal function: retrieve the div holding tooltips over modals and notifications
	 *
	 * @return jQuery the div selection
	 */
	function _getOverTooltipsDiv()
	{
		if (!_overTooltipsDiv)
		{
			_overTooltipsDiv = $('<div id="tooltips-over"></div>').appendTo(document.body);
		}

		return _overTooltipsDiv;
	}

	/**
	 * Check if a content is valid
	 * @param mixed content the value to check
	 * @return boolean true if valid, else false
	 */
	function _isValidContent(content)
	{
		return ((content instanceof jQuery) || typeof content === 'function' || (typeof content === 'string' && $.trim(content).length > 0));
	}

	/**
	 * Parse the content or try to extract it from the element
	 * @param mixed content (see tooltip() for details)
	 * @param jQuery target the target element
	 * @return string|jQuery|boolean the content, or false if none
	 */
	function _parseContent(content, target)
	{
		var title, children;

		// If valid
		if (_isValidContent(content))
		{
			return content;
		}

		// Test if content set as data-tooltip-content
		content = target.data('tooltip-content');
		if (_isValidContent(content))
		{
			// Clear
			if (target[0].title && target[0].title.length)
			{
				target[0].title = '';
				target.data('tooltip-title', {
					value:		content,
					element:	target[0]
				});
			}

			return content;
		}

		// Test if there is a stored title
		title = target.data('tooltip-title');
		if (title)
		{
			return title.value;
		}

		// Check title attribute
		if (target[0].title && $.trim(target[0].title).length > 0)
		{
			content = target[0].title;
			target[0].title = '';
			target.data('tooltip-title', {
				value:		content,
				element:	target[0]
			});

			return content;
		}

		// For elements with an unique child, use the child title
		children = target.children();
		if (children.length === 1 && children[0].title && $.trim(children[0].title).length > 0)
		{
			content = children[0].title;
			children[0].title = '';
			target.data('tooltip-title', {
				value:		content,
				element:	children[0]
			});

			return content;
		}

		// No content
		return false;
	}

	/**
	 * Restore element's title if needed
	 * @param jQuery target the target element
	 * @return void
	 */
	function _restoreTitle(target)
	{
		// Test if there is a stored title
		var title = target.data('tooltip-title');
		if (title)
		{
			title.element.title = title.value;
			target.removeData('tooltip-title');
		}
	}

	/**
	 * Display a tooltip over an element. If the page is not yet ready, delay the tooltip until it is ready.
	 *
	 * @var string|function|jQuery content a text or html content to display, or a function to run on the element to get the content
	 * (can be omitted, auto-detect if not defined or empty)
	 * @var object options an object with any options for the tooltip - optional (see defaults for more details). If not set, the function
	 * will try to retrieve any option of an existing or delayed tooltip on the same element, so when changing the content of a tooltip
	 * just call the function without options
	 */
	$.fn.tooltip = function(content, options)
	{
		// Settings
		var globalSettings = $.extend({}, $.fn.tooltip.defaults, options),

			// If no options were given
			noOptions = false;

		// Options format
		if (typeof content === 'object' && !(content instanceof jQuery))
		{
			options = content;
			content = '';
		}
		if (!options || typeof options !== 'object')
		{
			noOptions = true;
			options = {};
		}

		// Initial setup
		this.each(function(i)
		{
				// Tooltip target
			var target = $(this),

				// Is the target a replacement element?
				replacement = target.data('replaced'),

				// Inline settings
				inlineOptions = target.data('tooltip-options') || (replacement ? (replacement.data('tooltip-options') || {}) : {}),

				// Check if a tooltip is delayed for creation
				awaiting = target.data('tooltip-awaiting'),

				// Ajax promise (if any) and loaded data
				promise = false,

				// Functions
				onMouseleave, onBlur, onClick;

			/*
			 * If the document is not ready or we want some delay
			 */
			if (!$.isReady || (!options.ignoreDelay && (options.delay > 0 || inlineOptions.delay > 0)))
			{
				var delay = inlineOptions.delay || options.delay || 40,

					// Options
					thisOptions = options,

					// Timeout ID
					timeout,

					// Functions
					abort;

				// Parse content
				content = _parseContent(content, target);

				// If there is already a delayed tooltip
				if (awaiting)
				{
					// Stop timeout
					if (awaiting.abort() === false)
					{
						return;
					}

					// Merge options
					if (noOptions)
					{
						thisOptions = $.extend({}, awaiting.options);
					}
				}

				// Close on mouseleave
				if (thisOptions.removeOnMouseleave)
				{
					// Callback function
					onMouseleave = function(event)
					{
						// Abort tooltip
						abort();
					};

					// Bind
					target.on('mouseleave', onMouseleave);
				}

				// Close on click anywhere else
				if (thisOptions.removeOnBlur)
				{
					// Callback function
					onBlur = function(event)
					{
						// Abort tooltip
						abort();
					};

					// Bind
					doc.on('click touchend', onBlur);
				}

				// Function to abort tooltip
				abort = function(force, doNotRestore)
				{
					// Callback
					if (thisOptions.onAbort)
					{
						if (settings.onAbort.call(tooltip[0], target) === false && !force)
						{
							return false;
						}
					}

					// Stop timeout
					clearTimeout(timeout);

					// Clear data
					target.removeData('tooltip-awaiting');

					// Listeners
					if (onMouseleave)
					{
						target.off('mouseleave', onMouseleave);
					}
					if (onBlur)
					{
						doc.off('click touchend', onBlur);
					}

					// Stored title
					if (!doNotRestore)
					{
						_restoreTitle(target);
					}
				};

				// Store
				target.data('tooltip-awaiting', {
					options: thisOptions,
					abort: abort
				});

				// Delay
				timeout = setTimeout(function()
				{
					abort(false, true);
					target.tooltip(content, $.extend(thisOptions, { ignoreDelay: true }));

				}, delay);
			}
			/*
			 * Show tooltip
			 */
			else
			{
					// Check if a tooltip already exists
				var previous = target.data('tooltip'),

					// Previous tooltip settings
					previousSettings = {},

					// If there is a previous tooltip, do not animate
					skipAnimation = false,

					// Options from the delayed tooltip
					awaitingOptions = {},

					// Options
					settings,

					// Objects
					parent, tooltip, arrow, optionHolder,

					// Dom working
					dom, domHidden = false, placeholder,

					// Work vars
					noPointerEvents, arrowOffset, animValues, removeAnimValues, animateDistance,

					// Functions
					updatePosition, removeTooltip, endRemove;

				// If a tooltip already exists
				if (previous)
				{
					// If blocking, exit
					if (previous.settings.lock && (noOptions || !options.fromAjax))
					{
						return;
					}

					// Remove
					if (previous.removeTooltip(false, true) === false)
					{
						return;
					}

					// Retrieve previous settings
					if (noOptions)
					{
						previousSettings = previous.settings;
					}

					// Skip animation
					skipAnimation = true;
				}

				// If another tooltip is awaiting
				if (awaiting)
				{
					// If blocking, exit
					if (awaiting.options.lock)
					{
						return;
					}

					// Abort
					if (awaiting.abort() === false)
					{
						return;
					}

					// Retrieve options
					if (noOptions)
					{
						awaitingOptions = awaiting.options;
					}
				}

				// Check for tooltip alignement classes
				if (!options.position && !previousSettings.position && !awaitingOptions.position)
				{
					optionHolder = target.closest('.tooltip-top, .tooltip-right, .tooltip-bottom, .tooltip-left');
					if (optionHolder.length > 0)
					{
						awaitingOptions.position = /tooltip-(top|right|bottom|left)/.exec(optionHolder[0].className)[1];
					}
				}

				// Final settings
				settings = $.extend({}, globalSettings, inlineOptions, previousSettings, awaitingOptions);

				// Ajax loading
				if (settings.ajax && !settings.fromAjax)
				{
					// Mode
					if (typeof settings.ajax === 'object')
					{
						promise = settings.ajax;
					}
					else
					{
						promise = $.ajax(settings.ajax, settings.ajaxOptions);
					}

					// Prevent loading again by next tooltip
					settings.fromAjax = true;

					// On success
					promise.done(function(data)
					{
						// Check if tooltip is still visible
						var current = target.data('tooltip');
						if (current)
						{
							target.tooltip(data, settings);
						}
					});

					// On error
					promise.fail(function()
					{
						// Check if tooltip is still visible
						var current = target.data('tooltip');
						if (current)
						{
							target.tooltip(settings.ajaxErrorMessage, settings);
						}
					});
				}

				// If content is a function
				if (typeof content === 'function')
				{
					content = content.apply(this);
				}

				// Parse content
				content = _parseContent(content, target);
				if (content === false)
				{
					// No content, abort
					return;
				}
				if (content instanceof jQuery)
				{
					// Use dom element
					dom = content;
					content = '';
				}

				// Init
				if ( settings.local )
				{
					// Search closest block parent
					parent = target.parent();
					while ( !parent.is( 'body' ) && parent.css( 'display' ) !== 'block' )
					{
						parent = parent.parent();
					}

					// Make it positionned
					if ( parent.css( 'position' ) !== 'absolute' && parent.css( 'position' ) !== 'fixed' )
					{
						parent.addClass( 'relative' );
					}
				}
				else
				{
					parent = (target.closest('.notification, .modal').length > 0) ? _getOverTooltipsDiv() : _getStandardTooltipsDiv();
				}
				animateDistance = (settings.animate && !skipAnimation) ? settings.animateMove : 0;

				// If exclusive, remove existing one
				if (settings.exclusive && exclusive)
				{
					// The remove animation is skipped to prevent callbacks to fire in the wrong order
					if (exclusive.removeTooltip(false, true) === false)
					{
						return;
					}
				}

				// Create element
				noPointerEvents = settings.noPointerEvents ? ' no-pointer-events' : '';
				tooltip = $('<div class="message tooltip '+settings.classes.join(' ')+noPointerEvents+'">'+content+'</div>')
							.appendTo(parent)
							.data('tooltip-target', target);

				// Dom content
				if (dom)
				{
					// If hidden
					if (!dom.is(':visible'))
					{
						domHidden = true;
						dom.show();
					}

					// Check if already in the document
					if (dom.parent().length > 0)
					{
						placeholder = $('<span style="display:none"></span>').insertBefore(dom);
						dom.detach();
					}

					// Insert
					tooltip.append(dom);
				}

				// Arrow
				switch (settings.position.toLowerCase())
				{
					case 'right':
						arrow = $('<span class="block-arrow left"><span></span></span>').appendTo(tooltip);
						arrowOffset = arrow.parseCSSValue('margin-top');
						break;

					case 'bottom':
						arrow = $('<span class="block-arrow top"><span></span></span>').appendTo(tooltip);
						arrowOffset = arrow.parseCSSValue('margin-left');
						break;

					case 'left':
						arrow = $('<span class="block-arrow right"><span></span></span>').appendTo(tooltip);
						arrowOffset = arrow.parseCSSValue('margin-top');
						break;

					default:
						arrow = $('<span class="block-arrow"><span></span></span>').appendTo(tooltip);
						arrowOffset = arrow.parseCSSValue('margin-left');
						break;
				}

				// Function to update position
				updatePosition = function()
				{
					var targetpos = target.offset(),
						targetWidth = target.outerWidth(),
						targetHeight = target.outerHeight(),
						tooltipWidth = tooltip.outerWidth(),
						tooltipHeight = tooltip.outerHeight(),
						docWidth = $.template.viewportWidth,
						docHeight = $.template.viewportHeight,
						top, left, offset, position,
						arrowExtraOffset = 0;

					switch (settings.position)
					{
						case 'right':
							// Default position
							top = targetpos.top+Math.round(targetHeight/2)-Math.round(tooltipHeight/2);
							left = targetpos.left+targetWidth+settings.spacing;

							// Bounds check - horizontal
							if (left+tooltipWidth > docWidth-settings.screenPadding)
							{
								// Revert
								left = targetpos.left-tooltipWidth-settings.spacing;
								animateDistance *= -1;
								arrow.removeClass('left').addClass('right');
							}
							else
							{
								arrow.removeClass('right').addClass('left');
							}

							// Bounds check - vertical
							if (top < settings.screenPadding+doc.scrollTop())
							{
								offset = settings.screenPadding+doc.scrollTop()-top;
								arrowExtraOffset = -Math.min(offset, Math.round(tooltipHeight/2)-settings.arrowMargin);
								top += offset;
							}
							else if (top+tooltipHeight > doc.scrollTop()+docHeight-settings.screenPadding)
							{
								offset = doc.scrollTop()+docHeight-settings.screenPadding-tooltipHeight-top;
								arrowExtraOffset = Math.min(-offset, Math.round(tooltipHeight/2)-settings.arrowMargin);
								left += offset;
							}

							// Animation init
							left -= animateDistance;
							break;

						case 'bottom':
							// Default position
							top = targetpos.top+targetHeight+settings.spacing;
							left = targetpos.left+Math.round(targetWidth/2)-Math.round(tooltipWidth/2);

							// Bounds check - horizontal
							if (left < settings.screenPadding)
							{
								offset = settings.screenPadding-left;
								arrowExtraOffset = -Math.min(offset, Math.round(tooltipWidth/2)-settings.arrowMargin);
								left += offset;
							}
							else if (left+tooltipWidth > docWidth-settings.screenPadding)
							{
								offset = docWidth-settings.screenPadding-tooltipWidth-left;
								arrowExtraOffset = Math.min(-offset, Math.round(tooltipWidth/2)-settings.arrowMargin);
								left += offset;
							}

							// Bounds check - vertical
							if (top+tooltipHeight > docHeight-settings.screenPadding+doc.scrollTop())
							{
								// Revert
								top = targetpos.top-tooltipHeight-settings.spacing;
								animateDistance *= -1;
								arrow.removeClass('top').addClass('bottom');
							}
							else
							{
								arrow.removeClass('bottom').addClass('top');
							}

							// Animation init
							top -= animateDistance;
							break;

						case 'left':
							// Default position
							top = targetpos.top+Math.round(targetHeight/2)-Math.round(tooltipHeight/2);
							left = targetpos.left-tooltipWidth-settings.spacing;

							// Bounds check - horizontal
							if (left < settings.screenPadding+doc.scrollLeft())
							{
								// Revert
								left = targetpos.left+targetWidth+settings.spacing;
								animateDistance *= -1;
								arrow.removeClass('right').addClass('left');
							}
							else
							{
								arrow.removeClass('left').addClass('right');
							}

							// Bounds check - vertical
							if (top < settings.screenPadding+doc.scrollTop())
							{
								offset = settings.screenPadding+doc.scrollTop()-top;
								arrowExtraOffset = -Math.min(offset, Math.round(tooltipHeight/2)-settings.arrowMargin);
								top += offset;
							}
							else if (top+tooltipHeight > doc.scrollTop()+docHeight-settings.screenPadding)
							{
								offset = doc.scrollTop()+docHeight-settings.screenPadding-tooltipHeight-top;
								arrowExtraOffset = Math.min(-offset, Math.round(tooltipHeight/2)-settings.arrowMargin);
								left += offset;
							}

							// Animation init
							left += animateDistance;
							break;

						default:
							// Default position
							top = targetpos.top-tooltipHeight-settings.spacing;
							left = targetpos.left+Math.round(targetWidth/2)-Math.round(tooltipWidth/2);

							// Bounds check - horizontal
							if (left < settings.screenPadding)
							{
								offset = settings.screenPadding-left;
								arrowExtraOffset = -Math.min(offset, Math.round(tooltipWidth/2)-settings.arrowMargin);
								left += offset;
							}
							else if (left+tooltipWidth > docWidth-settings.screenPadding)
							{
								offset = docWidth-settings.screenPadding-tooltipWidth-left;
								arrowExtraOffset = Math.min(-offset, Math.round(tooltipWidth/2)-settings.arrowMargin);
								left += offset;
							}

							// Bounds check - vertical
							if (top < settings.screenPadding+doc.scrollTop())
							{
								// Revert
								top = targetpos.top+targetHeight+settings.spacing;
								animateDistance *= -1;
								arrow.removeClass('bottom').addClass('top');
							}
							else
							{
								arrow.removeClass('top').addClass('bottom');
							}

							// Animation init
							top += animateDistance;
							break;
					}

					// If local
					if ( settings.local )
					{
						// Local coordinates
						position = parent.offset();
						top -= position.top;
						left -= position.left;

						// Set position
						tooltip.css({
							top: top + 'px',
							left: left + 'px'
						});
					}
					else
					{
						// Set position
						tooltip.offset({
							top: top,
							left: left
						});
					}
					if (settings.position === 'left' || settings.position === 'right')
					{
						arrow.css('margin-top', (arrowExtraOffset === 0) ? '' : (arrowOffset+arrowExtraOffset)+'px');
					}
					else
					{
						arrow.css('margin-left', (arrowExtraOffset === 0) ? '' : (arrowOffset+arrowExtraOffset)+'px');
					}
				};

				// Watch movement (will set position)
				tooltip.trackElement(target, updatePosition);

				// Show animation
				if (settings.animate)
				{
					// Prepare
					animValues = {
						opacity: 1
					};
					removeAnimValues = {
						opacity: 0
					};

					// Move
					if (animateDistance !== 0)
					{
						switch (settings.position)
						{
							case 'right':
								animValues.left = '+='+animateDistance+'px';
								removeAnimValues.left = '-='+animateDistance+'px';
								break;

							case 'bottom':
								animValues.top = '+='+animateDistance+'px';
								removeAnimValues.top = '-='+animateDistance+'px';
								break;

							case 'left':
								animValues.left = '-='+animateDistance+'px';
								removeAnimValues.left = '+='+animateDistance+'px';
								break;

							default:
								animValues.top = '-='+animateDistance+'px';
								removeAnimValues.top = '+='+animateDistance+'px';
								break;
						}

						// Reset initial animation distance for further positioning
						animateDistance = 0;
					}

					// If no previous tip was replaced
					if (!skipAnimation)
					{
						// Here we go!
						tooltip.css({ opacity: 0 }).animate(animValues, settings.animateSpeed);
					}
				}

				// Remove
				removeTooltip = function(force, skipAnimation)
				{
					// Callback
					if (settings.onRemove)
					{
						if (settings.onRemove.call(tooltip[0], target) === false && !force)
						{
							return false;
						}
					}

					// Listeners
					if (onMouseleave)
					{
						target.off('mouseleave', onMouseleave);
					}
					if (onBlur)
					{
						doc.off('click touchend', onBlur);
					}
					if (onClick)
					{
						tooltip.off('click touchend', onClick);
					}

					// Clear data
					target.removeData('tooltip');

					// If exclusive, clear data
					if (settings.exclusive)
					{
						exclusive = false;
					}

					// Animation
					if (settings.animate && !skipAnimation)
					{
						// Remove
						tooltip.stop(true).addClass('tooltip-removed').animate(removeAnimValues, settings.animateSpeed, endRemove);
					}
					else
					{
						// Finalize
						endRemove();
					}

					return true;
				};

				// Finalize remove
				endRemove = function()
				{
					// Stored title
					_restoreTitle(target);

					// If pulled from the dom
					if (placeholder)
					{
						dom.detach().insertAfter(placeholder);
						placeholder.remove();
					}

					// If hidden
					if (domHidden)
					{
						dom.hide();
					}

					// Remove
					tooltip.remove();
				};

				// Store
				target.data('tooltip', {
					element: tooltip,
					settings: settings,
					updatePosition: updatePosition,
					removeTooltip: removeTooltip
				});

				// If exclusive, store
				if (settings.exclusive)
				{
					exclusive = {
						removeTooltip: removeTooltip,
						dom: dom
					};
				}

				// Close on mouseleave
				if (settings.removeOnMouseleave)
				{
					// Callback function
					onMouseleave = function(event)
					{
						// Remove tooltip
						removeTooltip();
					};

					// Bind
					target.on('mouseleave', onMouseleave);
				}

				// Close on click anywhere else
				if (settings.removeOnBlur)
				{
					// Callback function
					onBlur = function(event)
					{
						// Do not process if the event occurs inside the tooltip
						if ($(event.target).closest(tooltip[0]).length)
						{
							return;
						}

						// Do not process if default is prevented
						if (event.isDefaultPrevented())
						{
							return;
						}

						// Remove tooltip
						removeTooltip();
					};

					// Bind
					doc.on('click touchend', onBlur);
				}

				// Close on click on tooltip
				if (settings.removeOnClick && !settings.noPointerEvents)
				{
					// Callback function
					onClick = function(event)
					{
						// Remove tooltip
						removeTooltip();
					};

					// Bind
					tooltip.on('click touchend', onClick);
				}

				// Callback
				if (settings.onShow)
				{
					settings.onShow.call(tooltip[0], target);
				}
			}
		});

		return this;
	};

	/**
	 * Remove tooltip
	 * @param boolean force use true to close tooltips even when the onClose/onAbort callback functions return false (optional, default: false)
	 * @param boolean skipAnimation use true to disable the close animation (optional, default: false)
	 */
	$.fn.removeTooltip = function(force, skipAnimation)
	{
		this.each(function(i)
		{
			var target = $(this),
				tooltip = target.data('tooltip'),
				awaiting = target.data('tooltip-awaiting'),
				title;

			// If found
			if (tooltip)
			{
				// Remove
				if (tooltip.removeTooltip(force, skipAnimation) === false)
				{
					return;
				}
			}

			// If there is a delayed tooltip
			if (awaiting)
			{
				// Abort
				if (awaiting.abort(force) === false)
				{
					return;
				}
			}
		});

		return this;
	};

	/**
	 * Open a tooltip menu on click on any element
	 * @var string|function|jQuery content a text or html content to display, or a function to run on the element to get the content
	 * @var object options an object with any options for the tooltip - optional (see defaults for more details)
	 * @var string eventName the event on which to open the menu - optional (default: 'click')
	 */
	$.fn.menuTooltip = function(content, options, eventName)
	{
		// Parameters
		eventName = eventName || 'click';

		// Bind event
		this.on(eventName, function(event)
		{
			event.preventDefault();
			event.stopPropagation();

			// Open menu
			$(this).tooltip(content, $.extend({

				lock:				true,
				exclusive:			true,
				removeOnBlur:		true,
				noPointerEvents:	false

			}, options));
		});

		return this;
	};

	/**
	 * Tooltip function defaults
	 * @var object
	 */
	$.fn.tooltip.defaults = {
		/**
		 * Position: 'top', 'right', 'bottom' or 'left'
		 * @var string
		 */
		position: 'top',

		/**
		 * Should the tooltip be inserted locally (in the element's parent) or globally
		 * @var boolean
		 */
		local: false,

		/**
		 * Space between tooltip and the target element
		 * @var int
		 */
		spacing: 10,

		/**
		 * Extra classes (colors...)
		 * @var array
		 */
		classes: [],

		/**
		 * Prevent the tooltip from interacting with mouse
		 * @var boolean
		 */
		noPointerEvents: true,

		/**
		 * When true, prevent any other tooltip to show on the same target
		 * @var boolean
		 */
		lock: false,

		/**
		 * When true, will close any other open exclusive tooltip before showing
		 * @var boolean
		 */
		exclusive: false,

		/**
		 * Animate show/hide
		 * @var boolean
		 */
		animate: true,

		/**
		 * Animate movement (positive value will move outwards)
		 * @var int
		 */
		animateMove: 10,

		/**
		 * Animate speed (time (ms) value or jQuery spped string)
		 * @var int|string
		 */
		animateSpeed: 'fast',

		/**
		 * Delay before showing the tooltip
		 * @var int
		 */
		delay: 0,

		/**
		 * Ajax content loading: url to load or Promise object returned by an $.ajax() call
		 * @var string|object
		 */
		ajax: null,

		/**
		 * Options for the ajax call (same as $.ajax())
		 * @var object
		 */
		ajaxOptions: {},

		/**
		 * Message to display in tooltip if ajax request fails (text or html)
		 * @var string
		 */
		ajaxErrorMessage: 'Erro durante o carregamento de dados',

		/**
		 * Minimum distance from screen border
		 * @var int
		 */
		screenPadding: 10,

		/**
		 * Minimum spacing of tooltip arrow from border when tooltip is moved to fit in screen
		 * @var int
		 */
		arrowMargin: 10,

		/**
		 * Hide the tooltip when the mouse hovers out of the target element
		 * @var boolean
		 */
		removeOnMouseleave: false,

		/**
		 * Hide the tooltip when the user clicks anywhere else in the page
		 * @var boolean
		 */
		removeOnBlur: false,

		/**
		 * Hide the tooltip when the user clicks on the tooltip (only works if noPointerEvents is false)
		 * @var boolean
		 */
		removeOnClick: false,

		/**
		 * Callback on tooltip opening: function(target)
		 * Scope: the tooltip
		 * @var function
		 */
		onShow: null,

		/**
		 * Callback on tooltip remove: function(target)
		 * Note: the function may return false to prevent close.
		 * Scope: the tooltip
		 * @var function
		 */
		onRemove: null,

		/**
		 * Callback on delayed tooltip abort: function(target)
		 * Note: the function may return false to prevent abort.
		 * Scope: the target
		 * @var function
		 */
		onAbort: null
	};

	// Event binding
	if (!Modernizr || !Modernizr.touch)
	{
		doc.on('mouseenter', '.with-tooltip, .children-tooltip > *', function(event)
		{
			var element = $(this),
				parent = element.parent(),
				options = {
					delay:				100,
					removeOnMouseleave:	true
				};

			// Configuration for tooltips triggered by a parent element
			if (parent.hasClass('children-tooltip'))
			{
				options = $.extend(options, parent.data('tooltip-options'));
			}

			// Show tooltip
			element.tooltip(options);

		});
	}

})(jQuery, window, document);


$(document).ready(function()
{
    /*
     * JS login effect
     * Este script permitir efeitos para a pgina de login
*/
    // Elements
    var doc = $('html').addClass('js-login'),
        container = $('#container'),
        formBlock = $('#form-block'),

    // If layout is centered
        centered;

    /******* EDITAR ESTA SEO *******/

    /*
     * AJAX login
     * Essas funes iro processar o processo de login atravs do AJAX
     */
    $('#form-login').submit(function(event){

        // Values
        var login = $.trim($('#login').val()),
            pass = $.trim($('#pass').val()),
            dataForm = $(this).serialize(),
            url = $(this).attr('action');

        // Check inputs
        if (login.length === 0){
            // Display message
            displayError('Por favor, preencha seu login');
            return false;
        } else if (pass.length === 0){
            // Remova a mensagem de login vazia se exibida
            formBlock.clearMessages('Por favor, preencha seu login');
            // Display message
            displayError('Preencha sua senha');
            return false;
        } else {
            // Remove previous messages
            formBlock.clearMessages();

            // Show progress
            displayLoading('Verificando credenciais...');

            // Pare o comportamento normal
            event.preventDefault();


            $.ajax(url, {
                data: dataForm,
                method: 'POST',
                success: function(data){
                    if (data.logged == true){
                        setTimeout(function() {
                            document.location.href = data.redirect
                        }, 2000);
                    } else {
                        formBlock.clearMessages();
                        displayError(data.message);
                    }
                },
                error: function(){
                    formBlock.clearMessages();
                    displayError('Erro ao contactar ao servidor!');
                }
            });

        }
    });

    /*******  FINAL DA SEO DE EDITAR *******/

    // Handle resizing (principalmente para depurao)
    function handleLoginResize(){
        // Modo de deteco
        centered = (container.css('position') === 'absolute');
        // Defina altura mnima para layout mvel
        if (!centered){
            container.css('margin-top', '');
        } else {
            if (parseInt(container.css('margin-top'), 10) === 0)
            {
                centerForm(false);
            }
        }
    };

    // Registro e primeira ligao
    $(window).on('normalized-resize', handleLoginResize);
    handleLoginResize();

    /*
     * Funo central
     * @param boolean animate se deseja ou no animar a mudana de posio
     * @param string|element|array any jQuery selector, DOM element Ou conjunto de elementos DOM que devem ser ignorados
     * @return void
     */
    function centerForm(animate, ignore){
        // Se o layout estiver centrado
        if (centered){
            var siblings = formBlock.siblings(),
                finalSize = formBlock.outerHeight();
            // Ignored elements
            if (ignore){
                siblings = siblings.not(ignore);
            }
            // Get outros elementos de altura
            siblings.each(function(i){
                finalSize += $(this).outerHeight(true);
            });
            // Setup
            container[animate ? 'animate' : 'css']({ marginTop: -Math.round(finalSize/2)+'px' });
        }
    };

    // Ajuste vertical inicial
    centerForm(false);

    /**
     * Funo para exibir mensagens de erro
     * @param string message erro para exibir
     */
    function displayError(message){
        // Show message
        var message = formBlock.message(message, {
            append: false,
            arrow: 'bottom',
            classes: ['red-gradient'],
            animate: false	// Ns faremos animao mais tarde, precisamos conhecer primeiro a altura da mensagem
        });

        // Centralizao vertical (onde precisamos da altura da mensagem)
        centerForm(true, 'fast');

        // Observe o encerramento e mostre com efeito
        message.on('endfade', function(event)
        {
            // Isso ser chamado uma vez que a mensagem desapareceu e seja removida
            centerForm(true, message.get(0));

        }).hide().slideDown('fast');
    }

    /**
     * Funo para exibir as mensagens de carregamento
     * @param string message A mensagem a ser exibida
     */
    function displayLoading(message){
        // Show message
        var message = formBlock.message('<strong>'+message+'</strong>', {
            append: false,
            arrow: 'bottom',
            classes: ['blue-gradient', 'align-center'],
            stripes: true,
            darkStripes: false,
            closable: false,
            animate: false	// Ns faremos animao mais tarde, precisamos conhecer primeiro a altura da mensagem
        });
        // Centralizao vertical (onde precisamos da altura da mensagem)
        centerForm(true, 'fast');
        // Observe o encerramento e mostre com efeito
        message.on('endfade', function(event){
            // Isso ser chamado uma vez que a mensagem desapareceu e seja removida
            centerForm(true, message.get(0));

        }).hide().slideDown('fast');
    }
});
 /**
 *     ___ _    __   ____            _
 *    /   | |  / /  / __ \___  _____(_)____ ____ 
 *   / /| | | / /  / / / / _ \/ ___/ / __ `/ __ \
 *  / ___ | |/ /  / /_/ /  __(__  ) / /_/ / / / /
 * /_/  |_|___/  /_____/\___/____/_/\__, /_/ /_/ 
 *                                 /____/        
 * ------------ By Anselmo Velame --------------- 
 *
 * funtions global do sistema
 * Boas prticas estruturais dos padres essenciais para usar os plugins 
 */

/*
 * The semi-colon before the function invocation is a safety
 * net against concatenated scripts and/or other plugins
 * that are not closed properly.
 */
;(function($, window, document)
{
	/*
	 * window and document are passed through as local variables rather than as globals, because this (slightly)
	 * quickens the resolution process and can be more efficiently minified.
	 */

		// Objects cache
	var doc = $(document),

		// Global animation switch
		animate = true;

	// Navigable menus
	doc.on('click', '.navigable li, .navigable li > span, .navigable li > a, .navigable li > b', function(event)
	{
		// Only work if the element is the event's target
		if (event.target !== this)
		{
			return;
		}
		// Recarregar Menu ajax
		if ($(this).hasClass('navigable-ajax')){
			$("#catalog-ajax").remove();
		} else {
			$("#catalog").removeClass('navigable-ajax-loaded').addClass('navigable-ajax');
		}		

		// Clicked element
		var clicked = $(this),

			// LI element
			li = $(this).closest('li'),

			// Sub-menu
			submenu = li.children('ul:first'),

			// List of all ul above the current li
			allUL = li.parentsUntil('.navigable', 'ul'),

			// Current li ul
			parentUL = allUL.eq(0),

			// Main ul
			mainUL = allUL.eq(-1),

			// Root navigable element
			root = mainUL.closest('.navigable'),

			// Settings
			settings = $.extend({}, $.template.navigable, root.data('navigable-options')),

			// Back button
			back = root.children('.back'),
			backText,

			// Load indicator
			load = root.children('.load'),

			// Other vars
			current, url, delayedOpen, text, hidden, parentLi, parentLink;



		// Prepare on first call
		if (!mainUL.hasClass('fixed'))
		{
			root.height(mainUL.outerHeight(true));
			mainUL.addClass('fixed');
		}

		// Create back button if needed
		if (back.length === 0)
		{
			// Text
			text = settings.backText || '&nbsp;';

			// Create element
			back = $('<div class="back"><span class="back-arrow"></span><span class="back-text">'+text+'</span></div>').prependTo(root).click(function(event)
			{
				var current = root.data('navigableCurrent'),
					target, left, backHeight, parentLi, parentLink;

				// If no current element, we're already at the top level
				if (!current)
				{
					back.stop(true)[animate ? 'animate' : 'css']({ marginTop: -back.outerHeight()+'px' });
					return;
				}

				// Get parent target
				target = current.parent().closest('ul');

				// Check if working on the main UL
				if (target.hasClass('fixed'))
				{
					left = 0;
					backHeight = 0;
					root.removeData('navigableCurrent');
					back.stop(true)[animate ? 'animate' : 'css']({ marginTop: -back.outerHeight()+'px' });
				}
				else
				{
					// Text
					if (settings.backText)
					{
						backText.text(settings.backText);
					}
					else
					{
						parentLi = target.closest('li');
						parentLink = parentLi.children('a, b, span').not('.icon').first();
						if (!parentLink.length)
						{
							parentLink = parentLi;
						}
						backText.text(parentLink.contents().filter(function(){ return(this.nodeType == 3); }).text() );
					}

					left = -target.parentsUntil('.navigable', 'ul').length*100;
					backHeight = back.outerHeight();
					root.data('navigableCurrent', target);
				}

				// Set root element size according to target size
				root.stop(true)[animate ? 'animate' : 'css']({ height: (target.outerHeight(true)+backHeight)+'px' });

				// Move whole navigation to reveal target ul
				mainUL.stop(true)[animate ? 'animate' : 'css']({ left: left+'%' });

				// Send close event
				current.parent().closest('li').trigger('navigable-close');
			});

			// Hide it
			back.css({ marginTop: -back.outerHeight()+'px' });
		}

		// Button
		backText = back.children('.back-text');

		// If there is a load indicator on, remove it first
		if (load.length > 0)
		{
			// Currently displayed UL
			current = root.data('navigableCurrent') || mainUL;

			// Animation and callback
			mainUL.stop(true)[animate ? 'animate' : 'css']({ left: -(current.parentsUntil('.navigable', 'ul').length*100)+'%' }, 'fast');
			load.stop(true).removeData('navigable-target');
			if (animate)
			{
				load.animate({ right: '-10%' }, 'fast', function()
				{
					load.remove();
					clicked.click();
				});



				// Prevent default behavior
				event.preventDefault();

				// Done for now
				return;
			}
			else
			{
				load.remove();
			}
		}

		// If there is a submenu
		if (submenu.length > 0)
		{
			// Reveal hidden parents if needed for correct height processing
			hidden = root.tempShow();

			// If not ready yet
			if (parentUL.outerHeight(true) === 0 && allUL.length < 3)
			{
				// Delay action
				delayedOpen = function()
				{
					if (parentUL.outerHeight(true) > 0)
					{
						animate = false;
						clicked.click();
						animate = true;
					}
					else
					{
						setTimeout(delayedOpen, 40);
					}
				};
				setTimeout(delayedOpen, 40);
				return;
			}

			// Set as current
			root.data('navigableCurrent', submenu);

			// Hide previously open submenus
			parentUL.find('ul').hide();

			// Display parent menus
			allUL.show();

			// Display it
			submenu.show();

			// Correct position if needed
			submenu.add(allUL.not(':last')).each(function(i)
			{
				var menu = $(this),
					parent = menu.parent();

				if ($.inArray(parent.css('position'), ['relative', 'absolute']) > -1)
				{
					menu.css('top', -parent.position().top+'px');
				}
			});

			/*
			 * Animation
			 */

			// Text
			if (settings.backText)
			{
				backText.text(settings.backText);
			}
			else
			{
				parentLi = li;
				parentLink = parentLi.children('a, b, span').not('.icon').first();
				if (!parentLink.length)
				{
					parentLink = parentLi;
				}
				backText.text(parentLink.contents().filter(function(){ return(this.nodeType == 3); }).text() );
			}

			// Set root element size according to target size
			root.stop(true).height(parentUL.outerHeight(true)+back.outerHeight(true))[animate ? 'animate' : 'css']({ height: (submenu.outerHeight(true)+back.outerHeight())+'px' });

			// Move whole navigation to reveal target ul
			mainUL.stop(true)[animate ? 'animate' : 'css']({ left: -(allUL.length*100)+'%' });

			// Show back button
			back[animate ? 'animate' : 'css']({ marginTop: 0 });

			// Send open event
			li.trigger('navigable-open');

			// Hide previously hidden parents
			hidden.tempShowRevert();

			// Prevent default behavior
			event.preventDefault();
		}
		else if (clicked.hasClass('navigable-ajax'))
		{		

			// Get target url
			url = clicked.is('a') ? clicked.attr('href') : clicked.data('navigable-url');


			// If valid
			if (url && typeof url === 'string' && $.trim(url).length > 0 && url.substr(0, 1) !== '#')
			{
				// Load indicator
				load = $('<div class="load" style="right: -10%"></div>').appendTo(root);

				// Mmorise the current element in the load indicator, so in case of concurrent loads, only the last one gets open
				load.data('navigable-target', this);

				// Move whole navigation to reveal load indicator
				mainUL.stop(true)[animate ? 'animate' : 'css']({ left: -((allUL.length-1)*100+10)+'%' });

				// Show load
				load[animate ? 'animate' : 'css']({ right: '0%' });

				// Load submenu
				$.ajax(url, {
					error: function(jqXHR, textStatus, errorThrown)
					{
						// Refresh load notification since it may have changed since the request was sent
						var load = root.children('.load'),
							current;

						// If notification system is enabled
						if (window.notify)
						{
							window.notify('Falhou: error "'+textStatus+'"');
						}

						// If related load is still here
						if (load.length > 0 && load.data('navigable-target') === clicked[0])
						{
							// Currently displayed UL
							current = root.data('navigableCurrent') || mainUL;

							// Animation and callback
							mainUL.stop(true)[animate ? 'animate' : 'css']({ left: -(current.parentsUntil('.navigable', 'ul').length*100)+'%' }, 'fast');
							load.stop(true).removeData('navigable-target');
							if (animate)
							{
								load.animate({ right: '-10%' }, 'fast', function()
								{
									// Remove load, not needed anymore
									load.remove();
								});
							}
							else
							{
								load.remove();
							}
						}
					},
					success: function(data, textStatus, jqXHR)
					{
						// Refresh load notification since it may have changed since the request was sent
						var load = root.children('.load');

						// Remove ajax marker, mark as loaded
						clicked.removeClass('navigable-ajax').addClass('navigable-ajax-loaded');

						// Append data
						li.append(data);

						// If related load is still here
						if (load.length > 0 && load.data('navigable-target') === clicked[0])
						{
							// Remove load, not needed anymore
							load.remove();

							// Finally open the clicked element
							clicked.click();
						}

						// Trigger notification
						clicked.trigger('navigable-ajax-loaded');
					}
				});

				// Prevent default behavior
				event.preventDefault();
			}
		}
		else if (clicked.hasClass('navigable-ajax-loaded'))
		{

			// Provavelmente um menu ajax que no carregou nada, evite o comportamento padro
			event.preventDefault();
		}
	});

	/**
	 * Reset navigable position to main menu
	 */
	$.fn.navigableReset = function()
	{
		this.filter('.navigable').each( function(i)
		{
			// Navigable element
			var root = $(this),

				// Back button
				back = root.children('.back'),

				// Hidden parents
				hidden;

			// If valid
			if (back.length > 0)
			{
				// Reveal hidden parents if needed for correct height processing
				hidden = root.tempShow();

				// Walk back the arbo
				while (root.data('navigableCurrent'))
				{
					back.click();
				}

				// Hide previously hidden parents
				hidden.tempShowRevert();
			}
		});

		return this;
	};

	// Add to template setup function
	$.template.addSetupFunction(function(self, children)
	{
		// Current open menu element
		this.findIn(self, children, '.navigable-current').each(function(i)
		{
			var closest = $(this).closest('ul').closest('li, .navigable'),
				child;

			// Check if in a submenu
			if (closest.length > 0 && !closest.hasClass('navigable'))
			{
				// Disable animation
				animate = false;

				// Is there a span or a link?
				child = closest.children('a, span').first();
				if (child.length > 0)
				{
					child.click();
				}
				else
				{
					closest.click();
				}

				// Enable animation
				animate = true;
			}
		});

		return this;
	});

	/**
	 * Navigable menu defaults
	 * @var object
	 */
	$.template.navigable = {

		/**
		 * Text of the back button, or false to use the parent element's text
		 * @var string|boolean
		 */
		backText: false
	};

})(jQuery, window, document);